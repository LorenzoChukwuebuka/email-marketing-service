// package worker

// import (
// 	"context"
// 	db "email-marketing-service/internal/db/sqlc"
// 	"fmt"
// 	"log"
// 	"sync"
// 	"time"
// )

// type TaskType string

// const (
// 	TaskSendWelcomeEmail      TaskType = "email:send_welcome"
// 	TaskSendUserNotification  TaskType = "usernotification:send"
// 	TaskSendAdminNotification TaskType = "adminnotifcation:send"
// 	TaskSendEmail             TaskType = "email:send"
// 	TaskUserDetails           TaskType = "user:store_details"
// 	TaskSMTPSendEmail         TaskType = "smtp:sendemail"
// 	TaskAuditLogCreate        TaskType = "audit:log_create"
// 	TaskAuditLogUpdate        TaskType = "audit:log_update"
// 	TaskAuditLogDelete        TaskType = "audit:log_delete"
// 	TaskAuditLogLogin         TaskType = "audit:log_login"
// 	TaskAuditLogFailedLogin   TaskType = "audit:log_failed_login"
// )

// type Task struct {
// 	Type       TaskType
// 	Timestamp  time.Time
// 	Payload    any
// 	RetryCount int
// }

// type Worker struct {
// 	taskChan     chan Task
// 	shutdownChan chan struct{}
// 	wg           sync.WaitGroup
// 	maxRetries   int
// 	retryDelay   time.Duration
// 	mu           sync.Mutex
// 	Store        db.Store
// 	// emailClient  EmailClient
// 	// logger       Logger
// }

// func NewWorker(maxRetries int, retryDelay time.Duration) *Worker {
// 	return &Worker{
// 		taskChan:     make(chan Task), // buffered channel
// 		shutdownChan: make(chan struct{}),
// 		maxRetries:   maxRetries,
// 		retryDelay:   retryDelay,
// 	}
// }

// func (w *Worker) Start() {
// 	w.wg.Add(1)
// 	go w.run()
// 	log.Println("Worker started and listening for tasks")
// }

// func (w *Worker) run() {
// 	defer w.wg.Done()
// 	for {
// 		select {
// 		case task := <-w.taskChan:
// 			if err := w.processTaskWithRetry(context.Background(), task); err != nil {
// 				log.Printf("Unrecoverable error processing task: %v", err)
// 			}
// 		case <-w.shutdownChan:
// 			log.Println("Worker shutting down...")
// 			return
// 		}
// 	}
// }

// func (w *Worker) processTaskWithRetry(ctx context.Context, task Task) error {
// 	for attempt := 0; attempt <= w.maxRetries; attempt++ {
// 		err := w.processTask(ctx, task)
// 		if err == nil {
// 			log.Printf("Task %s processed successfully", task.Type)
// 			return nil
// 		}

// 		log.Printf("Error processing task %s (attempt %d/%d): %v",
// 			task.Type, attempt+1, w.maxRetries+1, err)

// 		if attempt == w.maxRetries {
// 			return fmt.Errorf("failed to process task after %d attempts: %w",
// 				w.maxRetries+1, err)
// 		}

// 		// Exponential backoff
// 		time.Sleep(w.retryDelay * time.Duration(1<<uint(attempt)))
// 		task.RetryCount++
// 	}
// 	return nil
// }

// func (w *Worker) processTask(ctx context.Context, task Task) error {
// 	switch task.Type {
// 	case TaskSendWelcomeEmail:
// 		payload, ok := task.Payload.(EmailPayload)
// 		if !ok {
// 			return fmt.Errorf("invalid payload type for TaskSendWelcomeEmail")
// 		}
// 		return ProcessWelcomeEmailTask(ctx, payload)

// 	default:
// 		return fmt.Errorf("unknown task type: %s", task.Type)
// 	}
// }

// func (w *Worker) EnqueueTask(taskType TaskType, payload interface{}) {
// 	task := Task{
// 		Type:       taskType,
// 		Timestamp:  time.Now(),
// 		Payload:    payload,
// 		RetryCount: 0,
// 	}

// 	w.taskChan <- task
// }

// // Shutdown gracefully shuts down the worker
// func (w *Worker) Shutdown(ctx context.Context) error {
// 	close(w.shutdownChan)

// 	// Process remaining tasks
// 	w.wg.Add(1)
// 	go func() {
// 		defer w.wg.Done()
// 		for task := range w.taskChan {
// 			if err := w.processTaskWithRetry(ctx, task); err != nil {
// 				log.Printf("Failed to process task during shutdown: %v", err)
// 			}
// 		}
// 	}()

// 	done := make(chan struct{})
// 	go func() {
// 		w.wg.Wait()
// 		close(w.taskChan)
// 		close(done)
// 	}()

// 	select {
// 	case <-done:
// 		log.Println("Worker shutdown complete")
// 		return nil
// 	case <-ctx.Done():
// 		return ctx.Err()
// 	}
// }

// // ForceShutdown immediately stops the worker without processing remaining tasks
// func (w *Worker) ForceShutdown() {
// 	select {
// 	case <-w.shutdownChan:
// 		return
// 	default:
// 		close(w.shutdownChan)
// 	}
// 	log.Println("Worker force shutdown")
// }

// // GetStats returns basic worker statistics
// func (w *Worker) GetStats() map[string]interface{} {
// 	w.mu.Lock()
// 	defer w.mu.Unlock()

// 	return map[string]interface{}{
// 		"queue_length": len(w.taskChan),
// 		"max_retries":  w.maxRetries,
// 		"retry_delay":  w.retryDelay.String(),
// 	}
// }


// Long Polling Client Implementation
class NotificationClient {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
    this.lastSeenId = null;
    this.polling = false;
  }

  async startPolling(onNewNotifications) {
    this.polling = true;
    
    while (this.polling) {
      try {
        const url = new URL(`${this.baseUrl}/notifications/poll`);
        if (this.lastSeenId) {
          url.searchParams.append('lastSeenId', this.lastSeenId);
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${this.token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.data && data.data.length > 0) {
          // Update lastSeenId to the newest notification
          this.lastSeenId = Math.max(...data.data.map(n => n.id));
          
          // Call the callback with new notifications
          onNewNotifications(data.data);
        }

        // Immediately reconnect (this is key for long polling)
        await new Promise(resolve => setTimeout(resolve, 100));

      } catch (error) {
        console.error('Polling error:', error);
        
        // Wait before retrying on error
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }
  }

  stopPolling() {
    this.polling = false;
  }
}

// Usage example
const client = new NotificationClient(
  'http://localhost:8080/api', 
  'your-jwt-token'
);

client.startPolling((notifications) => {
  console.log('New notifications:', notifications);
  // Update UI with new notifications
  notifications.forEach(notif => {
    displayNotification(notif);
  });
});

// Stop polling when needed (e.g., user logs out)
// client.stopPolling();




package controllers

import (
	"context"
	"fmt"
	"net/http"
	"time"
)

type UserController struct {
	userService *services.UserService
}

func NewUserController(userService *services.UserService) *UserController {
	return &UserController{
		userService: userService,
	}
}

// GetUserNotifications - Standard endpoint (no long polling)
func (c *UserController) GetUserNotifications(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
	defer cancel()

	userId, _, err := helper.ExtractUserId(r)
	if err != nil {
		helper.ErrorResponse(w, fmt.Errorf("can't fetch user id from jwt"), nil)
		return
	}

	result, err := c.userService.GetUserNotifications(ctx, userId)
	if err != nil {
		helper.ErrorResponse(w, err, nil)
		return
	}

	helper.SuccessResponse(w, http.StatusOK, result)
}

// GetUserNotificationsLongPoll - Long polling endpoint
func (c *UserController) GetUserNotificationsLongPoll(w http.ResponseWriter, r *http.Request) {
	// Long polling typically uses 30-60 second timeout
	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	userId, _, err := helper.ExtractUserId(r)
	if err != nil {
		helper.ErrorResponse(w, fmt.Errorf("can't fetch user id from jwt"), nil)
		return
	}

	// Optional: Get 'sinceId' from query params
	// Client sends the UUID of their last received notification
	var sinceID *string
	if sinceIDStr := r.URL.Query().Get("sinceId"); sinceIDStr != "" {
		sinceID = &sinceIDStr
	}

	// Set headers for long polling
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	result, err := c.userService.GetUserNotificationsLongPoll(ctx, userId, sinceID)
	if err != nil {
		helper.ErrorResponse(w, err, nil)
		return
	}

	helper.SuccessResponse(w, http.StatusOK, result)
}