// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contacts.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkIfContactEmailExists = `-- name: CheckIfContactEmailExists :one
SELECT EXISTS (
        SELECT 1
        FROM contacts
        WHERE
            email = $1
            AND user_id = $2
            AND deleted_at IS NULL
    ) AS exists
`

type CheckIfContactEmailExistsParams struct {
	Email  string    `json:"email"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckIfContactEmailExists(ctx context.Context, arg CheckIfContactEmailExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfContactEmailExists, arg.Email, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createContact = `-- name: CreateContact :exec
INSERT INTO
    contacts (
        company_id,
        first_name,
        last_name,
        email,
        from_origin,
        is_subscribed,
        user_id,
        created_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
`

type CreateContactParams struct {
	CompanyID    uuid.UUID    `json:"company_id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        string       `json:"email"`
	FromOrigin   string       `json:"from_origin"`
	IsSubscribed sql.NullBool `json:"is_subscribed"`
	UserID       uuid.UUID    `json:"user_id"`
	CreatedAt    sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) error {
	_, err := q.db.ExecContext(ctx, createContact,
		arg.CompanyID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.FromOrigin,
		arg.IsSubscribed,
		arg.UserID,
		arg.CreatedAt,
	)
	return err
}

const deleteContact = `-- name: DeleteContact :exec
UPDATE contacts
SET
    deleted_at = now()
WHERE
    id = $1
    AND user_id = $2
    AND deleted_at IS NULL
`

type DeleteContactParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteContact(ctx context.Context, arg DeleteContactParams) error {
	_, err := q.db.ExecContext(ctx, deleteContact, arg.ID, arg.UserID)
	return err
}

const getAllContacts = `-- name: GetAllContacts :many
SELECT
    c.id AS contact_id,
    c.company_id,
    c.first_name,
    c.last_name,
    c.email,
    c.from_origin,
    c.is_subscribed,
    c.user_id,
    c.created_at AS contact_created_at,
    c.updated_at AS contact_updated_at,
    ucg.id AS user_contact_group_id,
    ucg.user_id AS ucg_user_id,
    ucg.contact_group_id,
    ucg.contact_id,
    ucg.created_at AS ucg_created_at,
    ucg.updated_at AS ucg_updated_at,
    ucg.deleted_at AS ucg_deleted_at,
    cg.id AS group_id,
    cg.group_name,
    cg.description,
    cg.user_id AS group_creator_id,
    cg.created_at AS group_created_at,
    cg.updated_at AS group_updated_at
FROM
    contacts c
    LEFT JOIN user_contact_groups ucg ON c.id = ucg.contact_id
    AND ucg.deleted_at IS NULL
    LEFT JOIN contact_groups cg ON ucg.contact_group_id = cg.id
WHERE
    c.user_id = $1
    AND c.company_id = $2
    AND c.deleted_at IS NULL
ORDER BY c.first_name, c.last_name
LIMIT $3
OFFSET
    $4
`

type GetAllContactsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	CompanyID uuid.UUID `json:"company_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type GetAllContactsRow struct {
	ContactID          uuid.UUID      `json:"contact_id"`
	CompanyID          uuid.UUID      `json:"company_id"`
	FirstName          string         `json:"first_name"`
	LastName           string         `json:"last_name"`
	Email              string         `json:"email"`
	FromOrigin         string         `json:"from_origin"`
	IsSubscribed       sql.NullBool   `json:"is_subscribed"`
	UserID             uuid.UUID      `json:"user_id"`
	ContactCreatedAt   sql.NullTime   `json:"contact_created_at"`
	ContactUpdatedAt   sql.NullTime   `json:"contact_updated_at"`
	UserContactGroupID uuid.NullUUID  `json:"user_contact_group_id"`
	UcgUserID          uuid.NullUUID  `json:"ucg_user_id"`
	ContactGroupID     uuid.NullUUID  `json:"contact_group_id"`
	ContactID_2        uuid.NullUUID  `json:"contact_id_2"`
	UcgCreatedAt       sql.NullTime   `json:"ucg_created_at"`
	UcgUpdatedAt       sql.NullTime   `json:"ucg_updated_at"`
	UcgDeletedAt       sql.NullTime   `json:"ucg_deleted_at"`
	GroupID            uuid.NullUUID  `json:"group_id"`
	GroupName          sql.NullString `json:"group_name"`
	Description        sql.NullString `json:"description"`
	GroupCreatorID     uuid.NullUUID  `json:"group_creator_id"`
	GroupCreatedAt     sql.NullTime   `json:"group_created_at"`
	GroupUpdatedAt     sql.NullTime   `json:"group_updated_at"`
}

func (q *Queries) GetAllContacts(ctx context.Context, arg GetAllContactsParams) ([]GetAllContactsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllContacts,
		arg.UserID,
		arg.CompanyID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllContactsRow{}
	for rows.Next() {
		var i GetAllContactsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.CompanyID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.FromOrigin,
			&i.IsSubscribed,
			&i.UserID,
			&i.ContactCreatedAt,
			&i.ContactUpdatedAt,
			&i.UserContactGroupID,
			&i.UcgUserID,
			&i.ContactGroupID,
			&i.ContactID_2,
			&i.UcgCreatedAt,
			&i.UcgUpdatedAt,
			&i.UcgDeletedAt,
			&i.GroupID,
			&i.GroupName,
			&i.Description,
			&i.GroupCreatorID,
			&i.GroupCreatedAt,
			&i.GroupUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactsCount = `-- name: GetContactsCount :one
SELECT COUNT(*) AS total_count
FROM contacts c
WHERE
    c.user_id = $1
    AND c.company_id = $2
    AND c.deleted_at IS NULL
`

type GetContactsCountParams struct {
	UserID    uuid.UUID `json:"user_id"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) GetContactsCount(ctx context.Context, arg GetContactsCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getContactsCount, arg.UserID, arg.CompanyID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const updateContact = `-- name: UpdateContact :exec
UPDATE contacts
SET
    first_name = COALESCE(
        $1,
        first_name
    ),
    last_name = COALESCE(
        $2,
        last_name
    ),
    email = COALESCE($3, email),
    from_origin = COALESCE(
        $4,
        from_origin
    ),
    is_subscribed = $5,
    updated_at = now()
WHERE
    id = $6
    AND user_id = $7
    AND deleted_at IS NULL
`

type UpdateContactParams struct {
	FirstName    sql.NullString `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	Email        sql.NullString `json:"email"`
	FromOrigin   sql.NullString `json:"from_origin"`
	IsSubscribed sql.NullBool   `json:"is_subscribed"`
	ID           uuid.UUID      `json:"id"`
	UserID       uuid.UUID      `json:"user_id"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) error {
	_, err := q.db.ExecContext(ctx, updateContact,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.FromOrigin,
		arg.IsSubscribed,
		arg.ID,
		arg.UserID,
	)
	return err
}
