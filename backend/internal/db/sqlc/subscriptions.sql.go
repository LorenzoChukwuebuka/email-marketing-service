// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO
    subscriptions (
        company_id,
        plan_id,
        amount,
        billing_cycle,
        trial_starts_at,
        trial_ends_at,
        starts_at,
        ends_at,
        status,
        next_billing_date,
        auto_renew
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    ) RETURNING id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
`

type CreateSubscriptionParams struct {
	CompanyID       uuid.UUID       `json:"company_id"`
	PlanID          uuid.UUID       `json:"plan_id"`
	Amount          decimal.Decimal `json:"amount"`
	BillingCycle    sql.NullString  `json:"billing_cycle"`
	TrialStartsAt   sql.NullTime    `json:"trial_starts_at"`
	TrialEndsAt     sql.NullTime    `json:"trial_ends_at"`
	StartsAt        sql.NullTime    `json:"starts_at"`
	EndsAt          sql.NullTime    `json:"ends_at"`
	Status          sql.NullString  `json:"status"`
	NextBillingDate sql.NullTime    `json:"next_billing_date"`
	AutoRenew       sql.NullBool    `json:"auto_renew"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.CompanyID,
		arg.PlanID,
		arg.Amount,
		arg.BillingCycle,
		arg.TrialStartsAt,
		arg.TrialEndsAt,
		arg.StartsAt,
		arg.EndsAt,
		arg.Status,
		arg.NextBillingDate,
		arg.AutoRenew,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}

const getActiveSubscriptionByCompanyID = `-- name: GetActiveSubscriptionByCompanyID :one
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    company_id = $1
    AND status = 'active'
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveSubscriptionByCompanyID(ctx context.Context, companyID uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getActiveSubscriptionByCompanyID, companyID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date FROM subscriptions WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}

const listSubscriptionsByCompanyID = `-- name: ListSubscriptionsByCompanyID :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    company_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByCompanyID(ctx context.Context, companyID uuid.UUID) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsByCompanyID, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
