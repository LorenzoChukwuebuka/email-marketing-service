// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO
    subscriptions (
        company_id,
        plan_id,
        amount,
        billing_cycle,
        trial_starts_at,
        trial_ends_at,
        starts_at,
        ends_at,
        status,
        next_billing_date,
        auto_renew
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    ) RETURNING id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
`

type CreateSubscriptionParams struct {
	CompanyID       uuid.UUID       `json:"company_id"`
	PlanID          uuid.UUID       `json:"plan_id"`
	Amount          decimal.Decimal `json:"amount"`
	BillingCycle    sql.NullString  `json:"billing_cycle"`
	TrialStartsAt   sql.NullTime    `json:"trial_starts_at"`
	TrialEndsAt     sql.NullTime    `json:"trial_ends_at"`
	StartsAt        sql.NullTime    `json:"starts_at"`
	EndsAt          sql.NullTime    `json:"ends_at"`
	Status          sql.NullString  `json:"status"`
	NextBillingDate sql.NullTime    `json:"next_billing_date"`
	AutoRenew       sql.NullBool    `json:"auto_renew"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.CompanyID,
		arg.PlanID,
		arg.Amount,
		arg.BillingCycle,
		arg.TrialStartsAt,
		arg.TrialEndsAt,
		arg.StartsAt,
		arg.EndsAt,
		arg.Status,
		arg.NextBillingDate,
		arg.AutoRenew,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}

const getActiveSubscriptionByCompanyID = `-- name: GetActiveSubscriptionByCompanyID :one
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    company_id = $1
    AND status = 'active'
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveSubscriptionByCompanyID(ctx context.Context, companyID uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getActiveSubscriptionByCompanyID, companyID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}

const getActiveSubscriptionsEndingIn5Days = `-- name: GetActiveSubscriptionsEndingIn5Days :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    status = 'active'
    AND deleted_at IS NULL
    AND ends_at IS NOT NULL
    AND ends_at > NOW()
    AND ends_at <= NOW() + INTERVAL '5 days'
ORDER BY ends_at ASC
`

// Find all active subscriptions that end within 5 days
func (q *Queries) GetActiveSubscriptionsEndingIn5Days(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSubscriptionsEndingIn5Days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveSubscriptionsEndingInDays = `-- name: GetActiveSubscriptionsEndingInDays :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    status = 'active'
    AND deleted_at IS NULL
    AND ends_at IS NOT NULL
    AND ends_at > NOW()
    AND ends_at <= NOW() + INTERVAL '%d days'
ORDER BY ends_at ASC
`

// Find all active subscriptions that end within a specific number of days
func (q *Queries) GetActiveSubscriptionsEndingInDays(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSubscriptionsEndingInDays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveSubscriptionsNotExpired = `-- name: GetActiveSubscriptionsNotExpired :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    status = 'active'
    AND deleted_at IS NULL
    AND (ends_at IS NULL OR ends_at > NOW())
ORDER BY created_at DESC
`

// Find all active subscriptions where ends_at is greater than current time
func (q *Queries) GetActiveSubscriptionsNotExpired(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSubscriptionsNotExpired)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveSubscriptions = `-- name: GetAllActiveSubscriptions :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    status = 'active'
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetAllActiveSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentRunningSubscription = `-- name: GetCurrentRunningSubscription :one
SELECT
    s.id AS subscription_id,
    s.company_id,
    s.amount AS subscription_amount,
    s.billing_cycle,
    s.trial_starts_at,
    s.trial_ends_at,
    s.starts_at,
    s.ends_at,
    s.status AS subscription_status,
    s.created_at AS subscription_created_at,
    s.updated_at AS subscription_updated_at,
    p.id AS plan_id,
    p.name AS plan_name,
    p.description AS plan_description,
    p.price AS plan_price,
    p.billing_cycle AS plan_billing_cycle,
    p.status AS plan_status
FROM subscriptions s
    JOIN plans p ON s.plan_id = p.id
WHERE
    s.deleted_at IS NULL
    AND s.company_id = $1
ORDER BY s.created_at DESC
LIMIT 1
`

type GetCurrentRunningSubscriptionRow struct {
	SubscriptionID        uuid.UUID       `json:"subscription_id"`
	CompanyID             uuid.UUID       `json:"company_id"`
	SubscriptionAmount    decimal.Decimal `json:"subscription_amount"`
	BillingCycle          sql.NullString  `json:"billing_cycle"`
	TrialStartsAt         sql.NullTime    `json:"trial_starts_at"`
	TrialEndsAt           sql.NullTime    `json:"trial_ends_at"`
	StartsAt              sql.NullTime    `json:"starts_at"`
	EndsAt                sql.NullTime    `json:"ends_at"`
	SubscriptionStatus    sql.NullString  `json:"subscription_status"`
	SubscriptionCreatedAt sql.NullTime    `json:"subscription_created_at"`
	SubscriptionUpdatedAt sql.NullTime    `json:"subscription_updated_at"`
	PlanID                uuid.UUID       `json:"plan_id"`
	PlanName              string          `json:"plan_name"`
	PlanDescription       sql.NullString  `json:"plan_description"`
	PlanPrice             decimal.Decimal `json:"plan_price"`
	PlanBillingCycle      sql.NullString  `json:"plan_billing_cycle"`
	PlanStatus            sql.NullString  `json:"plan_status"`
}

func (q *Queries) GetCurrentRunningSubscription(ctx context.Context, companyID uuid.UUID) (GetCurrentRunningSubscriptionRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentRunningSubscription, companyID)
	var i GetCurrentRunningSubscriptionRow
	err := row.Scan(
		&i.SubscriptionID,
		&i.CompanyID,
		&i.SubscriptionAmount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.SubscriptionStatus,
		&i.SubscriptionCreatedAt,
		&i.SubscriptionUpdatedAt,
		&i.PlanID,
		&i.PlanName,
		&i.PlanDescription,
		&i.PlanPrice,
		&i.PlanBillingCycle,
		&i.PlanStatus,
	)
	return i, err
}

const getExpiredActiveSubscriptions = `-- name: GetExpiredActiveSubscriptions :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    status = 'active'
    AND deleted_at IS NULL
    AND ends_at IS NOT NULL
    AND ends_at <= NOW()
ORDER BY ends_at DESC
`

// Find subscriptions that are marked as 'active' but have actually expired
func (q *Queries) GetExpiredActiveSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getExpiredActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date FROM subscriptions WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}

const listSubscriptionsByCompanyID = `-- name: ListSubscriptionsByCompanyID :many
SELECT id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
FROM subscriptions
WHERE
    company_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByCompanyID(ctx context.Context, companyID uuid.UUID) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsByCompanyID, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PlanID,
			&i.Amount,
			&i.BillingCycle,
			&i.TrialStartsAt,
			&i.TrialEndsAt,
			&i.StartsAt,
			&i.EndsAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NextBillingDate,
			&i.AutoRenew,
			&i.CancellationReason,
			&i.LastPaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions
SET
    status = $2,
    updated_at = NOW()
WHERE
    id = $1
    AND deleted_at IS NULL RETURNING id, company_id, plan_id, amount, billing_cycle, trial_starts_at, trial_ends_at, starts_at, ends_at, status, created_at, updated_at, deleted_at, next_billing_date, auto_renew, cancellation_reason, last_payment_date
`

type UpdateSubscriptionStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, updateSubscriptionStatus, arg.ID, arg.Status)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PlanID,
		&i.Amount,
		&i.BillingCycle,
		&i.TrialStartsAt,
		&i.TrialEndsAt,
		&i.StartsAt,
		&i.EndsAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NextBillingDate,
		&i.AutoRenew,
		&i.CancellationReason,
		&i.LastPaymentDate,
	)
	return i, err
}
