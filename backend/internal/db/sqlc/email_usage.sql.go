// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email_usage.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkEmailLimitExceeded = `-- name: CheckEmailLimitExceeded :one
SELECT
    id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails,
    CASE
        WHEN emails_sent >= emails_limit THEN true
        ELSE false
    END as limit_exceeded,
    (emails_limit - emails_sent) as remaining_emails
FROM email_usage
WHERE
    company_id = $1
    AND usage_period_start = $2
    AND period_type = $3
`

type CheckEmailLimitExceededParams struct {
	CompanyID        uuid.UUID `json:"company_id"`
	UsagePeriodStart time.Time `json:"usage_period_start"`
	PeriodType       string    `json:"period_type"`
}

type CheckEmailLimitExceededRow struct {
	ID                uuid.UUID     `json:"id"`
	CompanyID         uuid.UUID     `json:"company_id"`
	SubscriptionID    uuid.UUID     `json:"subscription_id"`
	UsagePeriodStart  time.Time     `json:"usage_period_start"`
	UsagePeriodEnd    time.Time     `json:"usage_period_end"`
	PeriodType        string        `json:"period_type"`
	EmailsSent        sql.NullInt32 `json:"emails_sent"`
	EmailsLimit       int32         `json:"emails_limit"`
	CreatedAt         sql.NullTime  `json:"created_at"`
	UpdatedAt         sql.NullTime  `json:"updated_at"`
	RemainingEmails   sql.NullInt32 `json:"remaining_emails"`
	LimitExceeded     bool          `json:"limit_exceeded"`
	RemainingEmails_2 int32         `json:"remaining_emails_2"`
}

func (q *Queries) CheckEmailLimitExceeded(ctx context.Context, arg CheckEmailLimitExceededParams) (CheckEmailLimitExceededRow, error) {
	row := q.db.QueryRowContext(ctx, checkEmailLimitExceeded, arg.CompanyID, arg.UsagePeriodStart, arg.PeriodType)
	var i CheckEmailLimitExceededRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SubscriptionID,
		&i.UsagePeriodStart,
		&i.UsagePeriodEnd,
		&i.PeriodType,
		&i.EmailsSent,
		&i.EmailsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RemainingEmails,
		&i.LimitExceeded,
		&i.RemainingEmails_2,
	)
	return i, err
}

const createDailyEmailUsage = `-- name: CreateDailyEmailUsage :one
INSERT INTO
    email_usage (
        company_id,
        subscription_id,
        usage_period_start,
        usage_period_end,
        period_type,
        emails_sent,
        emails_limit
    )
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
`

type CreateDailyEmailUsageParams struct {
	CompanyID        uuid.UUID     `json:"company_id"`
	SubscriptionID   uuid.UUID     `json:"subscription_id"`
	UsagePeriodStart time.Time     `json:"usage_period_start"`
	UsagePeriodEnd   time.Time     `json:"usage_period_end"`
	PeriodType       string        `json:"period_type"`
	EmailsSent       sql.NullInt32 `json:"emails_sent"`
	EmailsLimit      int32         `json:"emails_limit"`
}

func (q *Queries) CreateDailyEmailUsage(ctx context.Context, arg CreateDailyEmailUsageParams) (EmailUsage, error) {
	row := q.db.QueryRowContext(ctx, createDailyEmailUsage,
		arg.CompanyID,
		arg.SubscriptionID,
		arg.UsagePeriodStart,
		arg.UsagePeriodEnd,
		arg.PeriodType,
		arg.EmailsSent,
		arg.EmailsLimit,
	)
	var i EmailUsage
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SubscriptionID,
		&i.UsagePeriodStart,
		&i.UsagePeriodEnd,
		&i.PeriodType,
		&i.EmailsSent,
		&i.EmailsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RemainingEmails,
	)
	return i, err
}

const getCompaniesNearLimit = `-- name: GetCompaniesNearLimit :many
SELECT 
    eu.id, eu.company_id, eu.subscription_id, eu.usage_period_start, eu.usage_period_end, eu.period_type, eu.emails_sent, eu.emails_limit, eu.created_at, eu.updated_at, eu.remaining_emails,
    c.companyname as company_name,
    ROUND((eu.emails_sent::DECIMAL / eu.emails_limit::DECIMAL) * 100, 2) as usage_percentage
FROM email_usage eu
JOIN companies c ON c.id = eu.company_id
WHERE eu.period_type = $1
  AND eu.usage_period_start <= CURRENT_DATE 
  AND eu.usage_period_end >= CURRENT_DATE
  AND (eu.emails_sent::DECIMAL / eu.emails_limit::DECIMAL) >= $2
ORDER BY usage_percentage DESC
`

type GetCompaniesNearLimitParams struct {
	PeriodType string        `json:"period_type"`
	EmailsSent sql.NullInt32 `json:"emails_sent"`
}

type GetCompaniesNearLimitRow struct {
	ID               uuid.UUID      `json:"id"`
	CompanyID        uuid.UUID      `json:"company_id"`
	SubscriptionID   uuid.UUID      `json:"subscription_id"`
	UsagePeriodStart time.Time      `json:"usage_period_start"`
	UsagePeriodEnd   time.Time      `json:"usage_period_end"`
	PeriodType       string         `json:"period_type"`
	EmailsSent       sql.NullInt32  `json:"emails_sent"`
	EmailsLimit      int32          `json:"emails_limit"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	RemainingEmails  sql.NullInt32  `json:"remaining_emails"`
	CompanyName      sql.NullString `json:"company_name"`
	UsagePercentage  string         `json:"usage_percentage"`
}

func (q *Queries) GetCompaniesNearLimit(ctx context.Context, arg GetCompaniesNearLimitParams) ([]GetCompaniesNearLimitRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompaniesNearLimit, arg.PeriodType, arg.EmailsSent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompaniesNearLimitRow{}
	for rows.Next() {
		var i GetCompaniesNearLimitRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.SubscriptionID,
			&i.UsagePeriodStart,
			&i.UsagePeriodEnd,
			&i.PeriodType,
			&i.EmailsSent,
			&i.EmailsLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RemainingEmails,
			&i.CompanyName,
			&i.UsagePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentBillingPeriod = `-- name: GetCurrentBillingPeriod :one
SELECT 
    s.company_id,
    s.id as subscription_id,
    s.created_at as subscription_start,
    DATE_TRUNC('month', CURRENT_DATE)::DATE as current_period_start,
    (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day')::DATE as current_period_end,
    ml.daily_limit,
    ml.monthly_limit,
    EXTRACT(DAY FROM (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day') - DATE_TRUNC('month', CURRENT_DATE)) + 1 as days_in_period
FROM subscriptions s
JOIN plans p ON s.plan_id = p.id
JOIN mailing_limits ml ON p.id = ml.plan_id
WHERE s.company_id = $1 
  AND s.status = 'active'
`

type GetCurrentBillingPeriodRow struct {
	CompanyID          uuid.UUID     `json:"company_id"`
	SubscriptionID     uuid.UUID     `json:"subscription_id"`
	SubscriptionStart  sql.NullTime  `json:"subscription_start"`
	CurrentPeriodStart time.Time     `json:"current_period_start"`
	CurrentPeriodEnd   time.Time     `json:"current_period_end"`
	DailyLimit         sql.NullInt32 `json:"daily_limit"`
	MonthlyLimit       sql.NullInt32 `json:"monthly_limit"`
	DaysInPeriod       int32         `json:"days_in_period"`
}

func (q *Queries) GetCurrentBillingPeriod(ctx context.Context, companyID uuid.UUID) (GetCurrentBillingPeriodRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentBillingPeriod, companyID)
	var i GetCurrentBillingPeriodRow
	err := row.Scan(
		&i.CompanyID,
		&i.SubscriptionID,
		&i.SubscriptionStart,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.DailyLimit,
		&i.MonthlyLimit,
		&i.DaysInPeriod,
	)
	return i, err
}

const getCurrentEmailUsage = `-- name: GetCurrentEmailUsage :one
SELECT id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
FROM email_usage
WHERE
    company_id = $1
    AND usage_period_start <= CURRENT_DATE
    AND usage_period_end >= CURRENT_DATE
`

func (q *Queries) GetCurrentEmailUsage(ctx context.Context, companyID uuid.UUID) (EmailUsage, error) {
	row := q.db.QueryRowContext(ctx, getCurrentEmailUsage, companyID)
	var i EmailUsage
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SubscriptionID,
		&i.UsagePeriodStart,
		&i.UsagePeriodEnd,
		&i.PeriodType,
		&i.EmailsSent,
		&i.EmailsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RemainingEmails,
	)
	return i, err
}

const getEmailUsageByCompany = `-- name: GetEmailUsageByCompany :many
SELECT id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
FROM email_usage
WHERE
    company_id = $1
ORDER BY usage_period_start DESC
`

func (q *Queries) GetEmailUsageByCompany(ctx context.Context, companyID uuid.UUID) ([]EmailUsage, error) {
	rows, err := q.db.QueryContext(ctx, getEmailUsageByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailUsage{}
	for rows.Next() {
		var i EmailUsage
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.SubscriptionID,
			&i.UsagePeriodStart,
			&i.UsagePeriodEnd,
			&i.PeriodType,
			&i.EmailsSent,
			&i.EmailsLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RemainingEmails,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailUsageByCompanyAndPeriod = `-- name: GetEmailUsageByCompanyAndPeriod :one
SELECT id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
FROM email_usage
WHERE
    company_id = $1
    AND usage_period_start = $2
    AND period_type = $3
`

type GetEmailUsageByCompanyAndPeriodParams struct {
	CompanyID        uuid.UUID `json:"company_id"`
	UsagePeriodStart time.Time `json:"usage_period_start"`
	PeriodType       string    `json:"period_type"`
}

func (q *Queries) GetEmailUsageByCompanyAndPeriod(ctx context.Context, arg GetEmailUsageByCompanyAndPeriodParams) (EmailUsage, error) {
	row := q.db.QueryRowContext(ctx, getEmailUsageByCompanyAndPeriod, arg.CompanyID, arg.UsagePeriodStart, arg.PeriodType)
	var i EmailUsage
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SubscriptionID,
		&i.UsagePeriodStart,
		&i.UsagePeriodEnd,
		&i.PeriodType,
		&i.EmailsSent,
		&i.EmailsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RemainingEmails,
	)
	return i, err
}

const getEmailUsageBySubscription = `-- name: GetEmailUsageBySubscription :many
SELECT id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
FROM email_usage
WHERE
    subscription_id = $1
ORDER BY usage_period_start DESC
`

func (q *Queries) GetEmailUsageBySubscription(ctx context.Context, subscriptionID uuid.UUID) ([]EmailUsage, error) {
	rows, err := q.db.QueryContext(ctx, getEmailUsageBySubscription, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailUsage{}
	for rows.Next() {
		var i EmailUsage
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.SubscriptionID,
			&i.UsagePeriodStart,
			&i.UsagePeriodEnd,
			&i.PeriodType,
			&i.EmailsSent,
			&i.EmailsLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RemainingEmails,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailUsageInDateRange = `-- name: GetEmailUsageInDateRange :many
SELECT id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
FROM email_usage
WHERE
    company_id = $1
    AND usage_period_start >= $2
    AND usage_period_end <= $3
    AND period_type = $4
ORDER BY usage_period_start ASC
`

type GetEmailUsageInDateRangeParams struct {
	CompanyID        uuid.UUID `json:"company_id"`
	UsagePeriodStart time.Time `json:"usage_period_start"`
	UsagePeriodEnd   time.Time `json:"usage_period_end"`
	PeriodType       string    `json:"period_type"`
}

func (q *Queries) GetEmailUsageInDateRange(ctx context.Context, arg GetEmailUsageInDateRangeParams) ([]EmailUsage, error) {
	rows, err := q.db.QueryContext(ctx, getEmailUsageInDateRange,
		arg.CompanyID,
		arg.UsagePeriodStart,
		arg.UsagePeriodEnd,
		arg.PeriodType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailUsage{}
	for rows.Next() {
		var i EmailUsage
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.SubscriptionID,
			&i.UsagePeriodStart,
			&i.UsagePeriodEnd,
			&i.PeriodType,
			&i.EmailsSent,
			&i.EmailsLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RemainingEmails,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailUsageStats = `-- name: GetEmailUsageStats :one
SELECT
    company_id,
    period_type,
    COUNT(*) as total_periods,
    SUM(emails_sent) as total_emails_sent,
    AVG(emails_sent) as avg_emails_per_period,
    MAX(emails_sent) as max_emails_in_period,
    SUM(emails_limit) as total_email_limits
FROM email_usage
WHERE
    company_id = $1
    AND period_type = $2
GROUP BY
    company_id,
    period_type
`

type GetEmailUsageStatsParams struct {
	CompanyID  uuid.UUID `json:"company_id"`
	PeriodType string    `json:"period_type"`
}

type GetEmailUsageStatsRow struct {
	CompanyID          uuid.UUID   `json:"company_id"`
	PeriodType         string      `json:"period_type"`
	TotalPeriods       int64       `json:"total_periods"`
	TotalEmailsSent    int64       `json:"total_emails_sent"`
	AvgEmailsPerPeriod float64     `json:"avg_emails_per_period"`
	MaxEmailsInPeriod  interface{} `json:"max_emails_in_period"`
	TotalEmailLimits   int64       `json:"total_email_limits"`
}

func (q *Queries) GetEmailUsageStats(ctx context.Context, arg GetEmailUsageStatsParams) (GetEmailUsageStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailUsageStats, arg.CompanyID, arg.PeriodType)
	var i GetEmailUsageStatsRow
	err := row.Scan(
		&i.CompanyID,
		&i.PeriodType,
		&i.TotalPeriods,
		&i.TotalEmailsSent,
		&i.AvgEmailsPerPeriod,
		&i.MaxEmailsInPeriod,
		&i.TotalEmailLimits,
	)
	return i, err
}

const getMonthlyEmailTrends = `-- name: GetMonthlyEmailTrends :many
SELECT
    DATE_TRUNC ('month', usage_period_start) as month,
    SUM(emails_sent) as total_emails_sent,
    AVG(emails_sent) as avg_daily_emails,
    COUNT(*) as active_days
FROM email_usage
WHERE
    company_id = $1
    AND period_type = 'daily'
    AND usage_period_start >= $2
    AND usage_period_start <= $3
GROUP BY
    DATE_TRUNC ('month', usage_period_start)
ORDER BY month ASC
`

type GetMonthlyEmailTrendsParams struct {
	CompanyID          uuid.UUID `json:"company_id"`
	UsagePeriodStart   time.Time `json:"usage_period_start"`
	UsagePeriodStart_2 time.Time `json:"usage_period_start_2"`
}

type GetMonthlyEmailTrendsRow struct {
	Month           int64   `json:"month"`
	TotalEmailsSent int64   `json:"total_emails_sent"`
	AvgDailyEmails  float64 `json:"avg_daily_emails"`
	ActiveDays      int64   `json:"active_days"`
}

func (q *Queries) GetMonthlyEmailTrends(ctx context.Context, arg GetMonthlyEmailTrendsParams) ([]GetMonthlyEmailTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyEmailTrends, arg.CompanyID, arg.UsagePeriodStart, arg.UsagePeriodStart_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyEmailTrendsRow{}
	for rows.Next() {
		var i GetMonthlyEmailTrendsRow
		if err := rows.Scan(
			&i.Month,
			&i.TotalEmailsSent,
			&i.AvgDailyEmails,
			&i.ActiveDays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementEmailsSent = `-- name: IncrementEmailsSent :one
UPDATE email_usage
SET
    emails_sent = emails_sent + $3,
    updated_at = CURRENT_TIMESTAMP
WHERE
    company_id = $1
    AND usage_period_start = $2
    AND period_type = 'daily' RETURNING id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
`

type IncrementEmailsSentParams struct {
	CompanyID        uuid.UUID     `json:"company_id"`
	UsagePeriodStart time.Time     `json:"usage_period_start"`
	EmailsSent       sql.NullInt32 `json:"emails_sent"`
}

func (q *Queries) IncrementEmailsSent(ctx context.Context, arg IncrementEmailsSentParams) (EmailUsage, error) {
	row := q.db.QueryRowContext(ctx, incrementEmailsSent, arg.CompanyID, arg.UsagePeriodStart, arg.EmailsSent)
	var i EmailUsage
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SubscriptionID,
		&i.UsagePeriodStart,
		&i.UsagePeriodEnd,
		&i.PeriodType,
		&i.EmailsSent,
		&i.EmailsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RemainingEmails,
	)
	return i, err
}

const updateEmailsSentAndRemaining = `-- name: UpdateEmailsSentAndRemaining :one
UPDATE email_usage
SET
    emails_sent = emails_sent + $2,
    remaining_emails = remaining_emails - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE
    company_id = $1
    AND id = $3 RETURNING id, company_id, subscription_id, usage_period_start, usage_period_end, period_type, emails_sent, emails_limit, created_at, updated_at, remaining_emails
`

type UpdateEmailsSentAndRemainingParams struct {
	CompanyID  uuid.UUID     `json:"company_id"`
	EmailsSent sql.NullInt32 `json:"emails_sent"`
	ID         uuid.UUID     `json:"id"`
}

func (q *Queries) UpdateEmailsSentAndRemaining(ctx context.Context, arg UpdateEmailsSentAndRemainingParams) (EmailUsage, error) {
	row := q.db.QueryRowContext(ctx, updateEmailsSentAndRemaining, arg.CompanyID, arg.EmailsSent, arg.ID)
	var i EmailUsage
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SubscriptionID,
		&i.UsagePeriodStart,
		&i.UsagePeriodEnd,
		&i.PeriodType,
		&i.EmailsSent,
		&i.EmailsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RemainingEmails,
	)
	return i, err
}
