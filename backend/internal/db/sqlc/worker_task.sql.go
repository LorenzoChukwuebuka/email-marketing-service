// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: worker_task.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const claimNextTask = `-- name: ClaimNextTask :one
UPDATE tasks
SET 
    status = 'processing',
    started_at = NOW(),
    updated_at = NOW()
WHERE id = (
    SELECT id
    FROM tasks
    WHERE status IN ('pending', 'failed')
        AND scheduled_at <= NOW()
        AND retry_count < max_retries
    ORDER BY scheduled_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, task_type, payload, status, retry_count, max_retries, error_message, scheduled_at, started_at, completed_at, created_at, updated_at
`

func (q *Queries) ClaimNextTask(ctx context.Context) (Task, error) {
	row := q.db.QueryRowContext(ctx, claimNextTask)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const cleanupOldTasks = `-- name: CleanupOldTasks :exec
DELETE FROM tasks 
WHERE status = 'completed' 
    AND completed_at < NOW() - ($1 || ' days')::interval
`

func (q *Queries) CleanupOldTasks(ctx context.Context, dollar_1 sql.NullString) error {
	_, err := q.db.ExecContext(ctx, cleanupOldTasks, dollar_1)
	return err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
    task_type,
    payload,
    status,
    max_retries,
    scheduled_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, task_type, payload, status, retry_count, max_retries, error_message, scheduled_at, started_at, completed_at, created_at, updated_at
`

type CreateTaskParams struct {
	TaskType    string          `json:"task_type"`
	Payload     json.RawMessage `json:"payload"`
	Status      string          `json:"status"`
	MaxRetries  int32           `json:"max_retries"`
	ScheduledAt time.Time       `json:"scheduled_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.TaskType,
		arg.Payload,
		arg.Status,
		arg.MaxRetries,
		arg.ScheduledAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFailedTasksCount = `-- name: GetFailedTasksCount :one
SELECT COUNT(*) FROM tasks WHERE status = 'failed' AND retry_count >= max_retries
`

func (q *Queries) GetFailedTasksCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFailedTasksCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPendingTasksCount = `-- name: GetPendingTasksCount :one
SELECT COUNT(*) FROM tasks WHERE status = 'pending'
`

func (q *Queries) GetPendingTasksCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingTasksCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProcessingTasksCount = `-- name: GetProcessingTasksCount :one
SELECT COUNT(*) FROM tasks WHERE status = 'processing'
`

func (q *Queries) GetProcessingTasksCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProcessingTasksCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, task_type, payload, status, retry_count, max_retries, error_message, scheduled_at, started_at, completed_at, created_at, updated_at FROM tasks WHERE id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, id int64) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTasksByStatus = `-- name: GetTasksByStatus :many
SELECT id, task_type, payload, status, retry_count, max_retries, error_message, scheduled_at, started_at, completed_at, created_at, updated_at FROM tasks 
WHERE status = $1 
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type GetTasksByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetTasksByStatus(ctx context.Context, arg GetTasksByStatusParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTasksByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTaskCompleted = `-- name: MarkTaskCompleted :exec
UPDATE tasks
SET 
    status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkTaskCompleted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markTaskCompleted, id)
	return err
}

const markTaskFailed = `-- name: MarkTaskFailed :exec
UPDATE tasks
SET 
    status = 'failed',
    retry_count = retry_count + 1,
    error_message = $2,
    updated_at = NOW(),
    scheduled_at = NOW() + ($3 || ' seconds')::interval
WHERE id = $1
`

type MarkTaskFailedParams struct {
	ID           int64          `json:"id"`
	ErrorMessage sql.NullString `json:"error_message"`
	Column3      sql.NullString `json:"column_3"`
}

func (q *Queries) MarkTaskFailed(ctx context.Context, arg MarkTaskFailedParams) error {
	_, err := q.db.ExecContext(ctx, markTaskFailed, arg.ID, arg.ErrorMessage, arg.Column3)
	return err
}

const resetStaleTasks = `-- name: ResetStaleTasks :exec
UPDATE tasks
SET 
    status = 'pending',
    started_at = NULL,
    updated_at = NOW()
WHERE status = 'processing'
    AND started_at < NOW() - ($1 || ' minutes')::interval
`

func (q *Queries) ResetStaleTasks(ctx context.Context, dollar_1 sql.NullString) error {
	_, err := q.db.ExecContext(ctx, resetStaleTasks, dollar_1)
	return err
}
