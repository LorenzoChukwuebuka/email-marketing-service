// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: support_tickets.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const closeStaleTickets = `-- name: CloseStaleTickets :many
UPDATE support_tickets
SET
    status = 'closed',
    updated_at = CURRENT_TIMESTAMP
WHERE
    status NOT IN('closed', 'resolved')
    AND (
        -- Tickets with no replies that are older than 48 hours
        (
            last_reply IS NULL
            AND created_at < CURRENT_TIMESTAMP - INTERVAL '48 hours'
        )
        OR
        -- Tickets with replies but last reply is older than 48 hours
        (
            last_reply IS NOT NULL
            AND last_reply < CURRENT_TIMESTAMP - INTERVAL '48 hours'
        )
    ) RETURNING id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
`

func (q *Queries) CloseStaleTickets(ctx context.Context) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, closeStaleTickets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Description,
			&i.TicketNumber,
			&i.Status,
			&i.Priority,
			&i.LastReply,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const closeTicketByID = `-- name: CloseTicketByID :one
UPDATE support_tickets
SET
    status = 'closed',
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $1 RETURNING id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
`

func (q *Queries) CloseTicketByID(ctx context.Context, id uuid.UUID) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, closeTicketByID, id)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Description,
		&i.TicketNumber,
		&i.Status,
		&i.Priority,
		&i.LastReply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSupportTicket = `-- name: CreateSupportTicket :one
INSERT INTO
    support_tickets (
        user_id,
        name,
        email,
        subject,
        description,
        ticket_number,
        status,
        priority
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    ) RETURNING id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
`

type CreateSupportTicketParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	Name         string         `json:"name"`
	Email        string         `json:"email"`
	Subject      string         `json:"subject"`
	Description  sql.NullString `json:"description"`
	TicketNumber string         `json:"ticket_number"`
	Status       sql.NullString `json:"status"`
	Priority     sql.NullString `json:"priority"`
}

func (q *Queries) CreateSupportTicket(ctx context.Context, arg CreateSupportTicketParams) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, createSupportTicket,
		arg.UserID,
		arg.Name,
		arg.Email,
		arg.Subject,
		arg.Description,
		arg.TicketNumber,
		arg.Status,
		arg.Priority,
	)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Description,
		&i.TicketNumber,
		&i.Status,
		&i.Priority,
		&i.LastReply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTicketFile = `-- name: CreateTicketFile :one
INSERT INTO
    ticket_files (
        message_id,
        file_name,
        file_path
    )
VALUES ($1, $2, $3) RETURNING id, message_id, file_name, file_path
`

type CreateTicketFileParams struct {
	MessageID uuid.UUID `json:"message_id"`
	FileName  string    `json:"file_name"`
	FilePath  string    `json:"file_path"`
}

func (q *Queries) CreateTicketFile(ctx context.Context, arg CreateTicketFileParams) (TicketFile, error) {
	row := q.db.QueryRowContext(ctx, createTicketFile, arg.MessageID, arg.FileName, arg.FilePath)
	var i TicketFile
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.FileName,
		&i.FilePath,
	)
	return i, err
}

const createTicketMessage = `-- name: CreateTicketMessage :one
INSERT INTO
    ticket_messages (
        ticket_id,
        user_id,
        message,
        is_admin
    )
VALUES ($1, $2, $3, $4) RETURNING id, ticket_id, user_id, message, is_admin, created_at, updated_at
`

type CreateTicketMessageParams struct {
	TicketID uuid.UUID    `json:"ticket_id"`
	UserID   uuid.UUID    `json:"user_id"`
	Message  string       `json:"message"`
	IsAdmin  sql.NullBool `json:"is_admin"`
}

func (q *Queries) CreateTicketMessage(ctx context.Context, arg CreateTicketMessageParams) (TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, createTicketMessage,
		arg.TicketID,
		arg.UserID,
		arg.Message,
		arg.IsAdmin,
	)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.UserID,
		&i.Message,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findTicketByID = `-- name: FindTicketByID :one
SELECT id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at FROM support_tickets WHERE id = $1
`

func (q *Queries) FindTicketByID(ctx context.Context, id uuid.UUID) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, findTicketByID, id)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Description,
		&i.TicketNumber,
		&i.Status,
		&i.Priority,
		&i.LastReply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllTicketsCount = `-- name: GetAllTicketsCount :one
SELECT COUNT(*) FROM support_tickets
`

func (q *Queries) GetAllTicketsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAllTicketsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllTicketsWithPagination = `-- name: GetAllTicketsWithPagination :many
SELECT 
   id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
FROM support_tickets
WHERE 
    CASE 
        WHEN $1::text != '' THEN 
            (subject ILIKE '%' || $1 || '%' OR 
             ticket_number ILIKE '%' || $1 || '%' OR 
             name ILIKE '%' || $1 || '%' OR 
             email ILIKE '%' || $1 || '%')
        ELSE TRUE
    END
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllTicketsWithPaginationParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetAllTicketsWithPagination(ctx context.Context, arg GetAllTicketsWithPaginationParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, getAllTicketsWithPagination, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Description,
			&i.TicketNumber,
			&i.Status,
			&i.Priority,
			&i.LastReply,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClosedTicketsCount = `-- name: GetClosedTicketsCount :one
SELECT COUNT(*) FROM support_tickets WHERE status = 'closed'
`

func (q *Queries) GetClosedTicketsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getClosedTicketsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getClosedTicketsWithPagination = `-- name: GetClosedTicketsWithPagination :many
SELECT 
    id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
FROM support_tickets
WHERE 
    status = 'closed'
    AND CASE 
        WHEN $1::text != '' THEN 
            (subject ILIKE '%' || $1 || '%' OR 
             ticket_number ILIKE '%' || $1 || '%' OR 
             name ILIKE '%' || $1 || '%' OR 
             email ILIKE '%' || $1 || '%')
        ELSE TRUE
    END
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetClosedTicketsWithPaginationParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetClosedTicketsWithPagination(ctx context.Context, arg GetClosedTicketsWithPaginationParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, getClosedTicketsWithPagination, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Description,
			&i.TicketNumber,
			&i.Status,
			&i.Priority,
			&i.LastReply,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageFiles = `-- name: GetMessageFiles :many
SELECT id, message_id, file_name, file_path FROM ticket_files WHERE message_id = $1
`

func (q *Queries) GetMessageFiles(ctx context.Context, messageID uuid.UUID) ([]TicketFile, error) {
	rows, err := q.db.QueryContext(ctx, getMessageFiles, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TicketFile{}
	for rows.Next() {
		var i TicketFile
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.FileName,
			&i.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingTicketsCount = `-- name: GetPendingTicketsCount :one
SELECT COUNT(*) FROM support_tickets WHERE status = 'pending'
`

func (q *Queries) GetPendingTicketsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingTicketsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPendingTicketsWithPagination = `-- name: GetPendingTicketsWithPagination :many
SELECT 
     id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
FROM support_tickets
WHERE 
    status = 'pending'
    AND CASE 
        WHEN $1::text != '' THEN 
            (subject ILIKE '%' || $1 || '%' OR 
             ticket_number ILIKE '%' || $1 || '%' OR 
             name ILIKE '%' || $1 || '%' OR 
             email ILIKE '%' || $1 || '%')
        ELSE TRUE
    END
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetPendingTicketsWithPaginationParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetPendingTicketsWithPagination(ctx context.Context, arg GetPendingTicketsWithPaginationParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, getPendingTicketsWithPagination, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Description,
			&i.TicketNumber,
			&i.Status,
			&i.Priority,
			&i.LastReply,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketFiles = `-- name: GetTicketFiles :many
SELECT tf.id, tf.message_id, tf.file_name, tf.file_path
FROM
    ticket_files tf
    JOIN ticket_messages tm ON tf.message_id = tm.id
WHERE
    tm.ticket_id = $1
`

func (q *Queries) GetTicketFiles(ctx context.Context, ticketID uuid.UUID) ([]TicketFile, error) {
	rows, err := q.db.QueryContext(ctx, getTicketFiles, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TicketFile{}
	for rows.Next() {
		var i TicketFile
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.FileName,
			&i.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketWithMessages = `-- name: GetTicketWithMessages :many
SELECT
    t.id as ticket_id,
    t.user_id as ticket_user_id,
    t.name as ticket_name,
    t.email as ticket_email,
    t.subject as ticket_subject,
    t.description as ticket_description,
    t.ticket_number,
    t.status as ticket_status,
    t.priority as ticket_priority,
    t.last_reply as ticket_last_reply,
    t.created_at as ticket_created_at,
    t.updated_at as ticket_updated_at,
    m.id as message_id,
    m.user_id as message_user_id,
    m.message,
    m.is_admin,
    m.created_at as message_created_at,
    m.updated_at as message_updated_at
FROM
    support_tickets t
    LEFT JOIN ticket_messages m ON t.id = m.ticket_id
WHERE
    t.id = $1
ORDER BY m.created_at ASC
`

type GetTicketWithMessagesRow struct {
	TicketID          uuid.UUID      `json:"ticket_id"`
	TicketUserID      uuid.UUID      `json:"ticket_user_id"`
	TicketName        string         `json:"ticket_name"`
	TicketEmail       string         `json:"ticket_email"`
	TicketSubject     string         `json:"ticket_subject"`
	TicketDescription sql.NullString `json:"ticket_description"`
	TicketNumber      string         `json:"ticket_number"`
	TicketStatus      sql.NullString `json:"ticket_status"`
	TicketPriority    sql.NullString `json:"ticket_priority"`
	TicketLastReply   sql.NullTime   `json:"ticket_last_reply"`
	TicketCreatedAt   time.Time      `json:"ticket_created_at"`
	TicketUpdatedAt   time.Time      `json:"ticket_updated_at"`
	MessageID         uuid.NullUUID  `json:"message_id"`
	MessageUserID     uuid.NullUUID  `json:"message_user_id"`
	Message           sql.NullString `json:"message"`
	IsAdmin           sql.NullBool   `json:"is_admin"`
	MessageCreatedAt  sql.NullTime   `json:"message_created_at"`
	MessageUpdatedAt  sql.NullTime   `json:"message_updated_at"`
}

func (q *Queries) GetTicketWithMessages(ctx context.Context, id uuid.UUID) ([]GetTicketWithMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicketWithMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTicketWithMessagesRow{}
	for rows.Next() {
		var i GetTicketWithMessagesRow
		if err := rows.Scan(
			&i.TicketID,
			&i.TicketUserID,
			&i.TicketName,
			&i.TicketEmail,
			&i.TicketSubject,
			&i.TicketDescription,
			&i.TicketNumber,
			&i.TicketStatus,
			&i.TicketPriority,
			&i.TicketLastReply,
			&i.TicketCreatedAt,
			&i.TicketUpdatedAt,
			&i.MessageID,
			&i.MessageUserID,
			&i.Message,
			&i.IsAdmin,
			&i.MessageCreatedAt,
			&i.MessageUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketsByUserID = `-- name: GetTicketsByUserID :many
SELECT id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
FROM support_tickets
WHERE
    user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetTicketsByUserID(ctx context.Context, userID uuid.UUID) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, getTicketsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Description,
			&i.TicketNumber,
			&i.Status,
			&i.Priority,
			&i.LastReply,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE support_tickets
SET
    status = $2,
    last_reply = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $1 RETURNING id, user_id, name, email, subject, description, ticket_number, status, priority, last_reply, created_at, updated_at
`

type UpdateTicketStatusParams struct {
	ID        uuid.UUID      `json:"id"`
	Status    sql.NullString `json:"status"`
	LastReply sql.NullTime   `json:"last_reply"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.ID, arg.Status, arg.LastReply)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Description,
		&i.TicketNumber,
		&i.Status,
		&i.Priority,
		&i.LastReply,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
