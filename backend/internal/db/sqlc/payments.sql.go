// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO
    payments (
        company_id,
        user_id,
        subscription_id,
        payment_id,
        amount,
        currency,
        payment_method,
        status,
        notes,
        transaction_reference,
        payment_date,
        billing_period_start,
        billing_period_end
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    ) RETURNING id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
`

type CreatePaymentParams struct {
	CompanyID            uuid.UUID       `json:"company_id"`
	UserID               uuid.UUID       `json:"user_id"`
	SubscriptionID       uuid.UUID       `json:"subscription_id"`
	PaymentID            sql.NullString  `json:"payment_id"`
	Amount               decimal.Decimal `json:"amount"`
	Currency             sql.NullString  `json:"currency"`
	PaymentMethod        sql.NullString  `json:"payment_method"`
	Status               sql.NullString  `json:"status"`
	Notes                sql.NullString  `json:"notes"`
	TransactionReference sql.NullString  `json:"transaction_reference"`
	PaymentDate          sql.NullTime    `json:"payment_date"`
	BillingPeriodStart   sql.NullTime    `json:"billing_period_start"`
	BillingPeriodEnd     sql.NullTime    `json:"billing_period_end"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.CompanyID,
		arg.UserID,
		arg.SubscriptionID,
		arg.PaymentID,
		arg.Amount,
		arg.Currency,
		arg.PaymentMethod,
		arg.Status,
		arg.Notes,
		arg.TransactionReference,
		arg.PaymentDate,
		arg.BillingPeriodStart,
		arg.BillingPeriodEnd,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TransactionReference,
		&i.PaymentDate,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.RefundedAmount,
		&i.IntegrityHash,
		&i.RefundDate,
	)
	return i, err
}

const getCompanyPaymentsWithSubscriptionInfo = `-- name: GetCompanyPaymentsWithSubscriptionInfo :many
SELECT p.id, p.company_id, p.user_id, p.subscription_id, p.payment_id, p.amount, p.currency, p.payment_method, p.status, p.notes, p.created_at, p.updated_at, p.deleted_at, p.transaction_reference, p.payment_date, p.billing_period_start, p.billing_period_end, p.refunded_amount, p.integrity_hash, p.refund_date, s.plan_id, s.status as subscription_status, s.billing_cycle
FROM payments p
    JOIN subscriptions s ON p.subscription_id = s.id
WHERE
    p.company_id = $1
    AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $2
OFFSET
    $3
`

type GetCompanyPaymentsWithSubscriptionInfoParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type GetCompanyPaymentsWithSubscriptionInfoRow struct {
	ID                   uuid.UUID       `json:"id"`
	CompanyID            uuid.UUID       `json:"company_id"`
	UserID               uuid.UUID       `json:"user_id"`
	SubscriptionID       uuid.UUID       `json:"subscription_id"`
	PaymentID            sql.NullString  `json:"payment_id"`
	Amount               decimal.Decimal `json:"amount"`
	Currency             sql.NullString  `json:"currency"`
	PaymentMethod        sql.NullString  `json:"payment_method"`
	Status               sql.NullString  `json:"status"`
	Notes                sql.NullString  `json:"notes"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	DeletedAt            sql.NullTime    `json:"deleted_at"`
	TransactionReference sql.NullString  `json:"transaction_reference"`
	PaymentDate          sql.NullTime    `json:"payment_date"`
	BillingPeriodStart   sql.NullTime    `json:"billing_period_start"`
	BillingPeriodEnd     sql.NullTime    `json:"billing_period_end"`
	RefundedAmount       decimal.Decimal `json:"refunded_amount"`
	IntegrityHash        sql.NullString  `json:"integrity_hash"`
	RefundDate           sql.NullTime    `json:"refund_date"`
	PlanID               uuid.UUID       `json:"plan_id"`
	SubscriptionStatus   sql.NullString  `json:"subscription_status"`
	BillingCycle         sql.NullString  `json:"billing_cycle"`
}

func (q *Queries) GetCompanyPaymentsWithSubscriptionInfo(ctx context.Context, arg GetCompanyPaymentsWithSubscriptionInfoParams) ([]GetCompanyPaymentsWithSubscriptionInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyPaymentsWithSubscriptionInfo, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanyPaymentsWithSubscriptionInfoRow{}
	for rows.Next() {
		var i GetCompanyPaymentsWithSubscriptionInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransactionReference,
			&i.PaymentDate,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.RefundedAmount,
			&i.IntegrityHash,
			&i.RefundDate,
			&i.PlanID,
			&i.SubscriptionStatus,
			&i.BillingCycle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date FROM payments WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentByID(ctx context.Context, id uuid.UUID) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TransactionReference,
		&i.PaymentDate,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.RefundedAmount,
		&i.IntegrityHash,
		&i.RefundDate,
	)
	return i, err
}

const getPaymentByPaymentID = `-- name: GetPaymentByPaymentID :one
SELECT id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date FROM payments WHERE payment_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentByPaymentID(ctx context.Context, paymentID sql.NullString) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByPaymentID, paymentID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TransactionReference,
		&i.PaymentDate,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.RefundedAmount,
		&i.IntegrityHash,
		&i.RefundDate,
	)
	return i, err
}

const getPaymentSuccessRate = `-- name: GetPaymentSuccessRate :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'successful') AS successful_count,
    COUNT(*) AS total_count,
    CASE 
        WHEN COUNT(*) = 0 THEN 0
        ELSE COUNT(*) FILTER (WHERE status = 'successful')::DECIMAL / COUNT(*)::DECIMAL * 100
    END AS success_rate
FROM payments
WHERE created_at >= $1 AND deleted_at IS NULL
`

type GetPaymentSuccessRateRow struct {
	SuccessfulCount int64       `json:"successful_count"`
	TotalCount      int64       `json:"total_count"`
	SuccessRate     interface{} `json:"success_rate"`
}

func (q *Queries) GetPaymentSuccessRate(ctx context.Context, createdAt sql.NullTime) (GetPaymentSuccessRateRow, error) {
	row := q.db.QueryRowContext(ctx, getPaymentSuccessRate, createdAt)
	var i GetPaymentSuccessRateRow
	err := row.Scan(&i.SuccessfulCount, &i.TotalCount, &i.SuccessRate)
	return i, err
}

const getPaymentsByDateRange = `-- name: GetPaymentsByDateRange :many
/* -- name: GetRecentPaymentActivity :many
SELECT p.*, c.name as companyname
FROM payments p
    JOIN companies c ON p.company_id = c.id
WHERE
    p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $1; */

SELECT id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
FROM payments
WHERE
    created_at BETWEEN $1 AND $2
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetPaymentsByDateRangeParams struct {
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
}

func (q *Queries) GetPaymentsByDateRange(ctx context.Context, arg GetPaymentsByDateRangeParams) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentsByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransactionReference,
			&i.PaymentDate,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.RefundedAmount,
			&i.IntegrityHash,
			&i.RefundDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalPaymentAmount = `-- name: GetTotalPaymentAmount :one
SELECT
    COALESCE(SUM(amount), 0) as total_amount,
    COALESCE(
        SUM(amount) FILTER (
            WHERE
                status = 'successful'
        ),
        0
    ) as successful_amount
FROM payments
WHERE
    company_id = $1
    AND deleted_at IS NULL
`

type GetTotalPaymentAmountRow struct {
	TotalAmount      interface{} `json:"total_amount"`
	SuccessfulAmount interface{} `json:"successful_amount"`
}

func (q *Queries) GetTotalPaymentAmount(ctx context.Context, companyID uuid.UUID) (GetTotalPaymentAmountRow, error) {
	row := q.db.QueryRowContext(ctx, getTotalPaymentAmount, companyID)
	var i GetTotalPaymentAmountRow
	err := row.Scan(&i.TotalAmount, &i.SuccessfulAmount)
	return i, err
}

const listPaymentsByCompanyID = `-- name: ListPaymentsByCompanyID :many
SELECT id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
FROM payments
WHERE
    company_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsByCompanyID(ctx context.Context, companyID uuid.UUID) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByCompanyID, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransactionReference,
			&i.PaymentDate,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.RefundedAmount,
			&i.IntegrityHash,
			&i.RefundDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsBySubscriptionID = `-- name: ListPaymentsBySubscriptionID :many
SELECT id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
FROM payments
WHERE
    subscription_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsBySubscriptionID(ctx context.Context, subscriptionID uuid.UUID) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsBySubscriptionID, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransactionReference,
			&i.PaymentDate,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.RefundedAmount,
			&i.IntegrityHash,
			&i.RefundDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByUserID = `-- name: ListPaymentsByUserID :many
SELECT id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
FROM payments
WHERE
    user_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsByUserID(ctx context.Context, userID uuid.UUID) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransactionReference,
			&i.PaymentDate,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.RefundedAmount,
			&i.IntegrityHash,
			&i.RefundDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordRefund = `-- name: RecordRefund :one
UPDATE payments
SET
    refunded_amount = $1,
    refund_date = CURRENT_TIMESTAMP,
    status = 'refunded',
    notes = COALESCE(notes || E '\n', '') || 'Refund: ' || $2,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $3
    AND deleted_at IS NULL RETURNING id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
`

type RecordRefundParams struct {
	RefundedAmount decimal.Decimal `json:"refunded_amount"`
	Notes          sql.NullString  `json:"notes"`
	ID             uuid.UUID       `json:"id"`
}

func (q *Queries) RecordRefund(ctx context.Context, arg RecordRefundParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, recordRefund, arg.RefundedAmount, arg.Notes, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TransactionReference,
		&i.PaymentDate,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.RefundedAmount,
		&i.IntegrityHash,
		&i.RefundDate,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET
    status = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $2
    AND deleted_at IS NULL RETURNING id, company_id, user_id, subscription_id, payment_id, amount, currency, payment_method, status, notes, created_at, updated_at, deleted_at, transaction_reference, payment_date, billing_period_start, billing_period_end, refunded_amount, integrity_hash, refund_date
`

type UpdatePaymentStatusParams struct {
	Status sql.NullString `json:"status"`
	ID     uuid.UUID      `json:"id"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentStatus, arg.Status, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TransactionReference,
		&i.PaymentDate,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.RefundedAmount,
		&i.IntegrityHash,
		&i.RefundDate,
	)
	return i, err
}
