// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: plan.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const archivePlan = `-- name: ArchivePlan :one
UPDATE plans
SET 
    status = 'archived',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, description, price, billing_cycle, status, created_at, updated_at, deleted_at
`

func (q *Queries) ArchivePlan(ctx context.Context, id uuid.UUID) (Plan, error) {
	row := q.db.QueryRowContext(ctx, archivePlan, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BillingCycle,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createMailingLimit = `-- name: CreateMailingLimit :one
INSERT INTO mailing_limits (
    id,
    plan_id,
    daily_limit,
    monthly_limit,
    max_recipients_per_mail,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, plan_id, daily_limit, monthly_limit, max_recipients_per_mail, created_at, updated_at, deleted_at
`

type CreateMailingLimitParams struct {
	ID                   uuid.UUID     `json:"id"`
	PlanID               uuid.UUID     `json:"plan_id"`
	DailyLimit           sql.NullInt32 `json:"daily_limit"`
	MonthlyLimit         sql.NullInt32 `json:"monthly_limit"`
	MaxRecipientsPerMail sql.NullInt32 `json:"max_recipients_per_mail"`
	CreatedAt            time.Time     `json:"created_at"`
	UpdatedAt            time.Time     `json:"updated_at"`
}

func (q *Queries) CreateMailingLimit(ctx context.Context, arg CreateMailingLimitParams) (MailingLimit, error) {
	row := q.db.QueryRowContext(ctx, createMailingLimit,
		arg.ID,
		arg.PlanID,
		arg.DailyLimit,
		arg.MonthlyLimit,
		arg.MaxRecipientsPerMail,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i MailingLimit
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.DailyLimit,
		&i.MonthlyLimit,
		&i.MaxRecipientsPerMail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createPlan = `-- name: CreatePlan :one
INSERT INTO plans (
    id,
    name,
    description,
    price,
    billing_cycle,
    status,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, description, price, billing_cycle, status, created_at, updated_at, deleted_at
`

type CreatePlanParams struct {
	ID           uuid.UUID       `json:"id"`
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        decimal.Decimal `json:"price"`
	BillingCycle sql.NullString  `json:"billing_cycle"`
	Status       sql.NullString  `json:"status"`
	CreatedAt    time.Time       `json:"created_at"`
	UpdatedAt    time.Time       `json:"updated_at"`
}

func (q *Queries) CreatePlan(ctx context.Context, arg CreatePlanParams) (Plan, error) {
	row := q.db.QueryRowContext(ctx, createPlan,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.BillingCycle,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BillingCycle,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createPlanFeature = `-- name: CreatePlanFeature :one
INSERT INTO plan_features (
    id,
    plan_id,
    name,
    description,
    value,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, plan_id, name, description, value, created_at, updated_at, deleted_at
`

type CreatePlanFeatureParams struct {
	ID          uuid.UUID      `json:"id"`
	PlanID      uuid.UUID      `json:"plan_id"`
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Value       sql.NullString `json:"value"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) CreatePlanFeature(ctx context.Context, arg CreatePlanFeatureParams) (PlanFeature, error) {
	row := q.db.QueryRowContext(ctx, createPlanFeature,
		arg.ID,
		arg.PlanID,
		arg.Name,
		arg.Description,
		arg.Value,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PlanFeature
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.Name,
		&i.Description,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePlanFeature = `-- name: DeletePlanFeature :exec
UPDATE plan_features
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeletePlanFeature(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePlanFeature, id)
	return err
}

const getMailingLimitByPlanID = `-- name: GetMailingLimitByPlanID :one
SELECT id, plan_id, daily_limit, monthly_limit, max_recipients_per_mail, created_at, updated_at, deleted_at FROM mailing_limits
WHERE plan_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMailingLimitByPlanID(ctx context.Context, planID uuid.UUID) (MailingLimit, error) {
	row := q.db.QueryRowContext(ctx, getMailingLimitByPlanID, planID)
	var i MailingLimit
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.DailyLimit,
		&i.MonthlyLimit,
		&i.MaxRecipientsPerMail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPlanByID = `-- name: GetPlanByID :one
SELECT id, name, description, price, billing_cycle, status, created_at, updated_at, deleted_at FROM plans
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPlanByID(ctx context.Context, id uuid.UUID) (Plan, error) {
	row := q.db.QueryRowContext(ctx, getPlanByID, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BillingCycle,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPlanByName = `-- name: GetPlanByName :one
SELECT id, name, description, price, billing_cycle, status, created_at, updated_at, deleted_at FROM plans
WHERE name = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPlanByName(ctx context.Context, name string) (Plan, error) {
	row := q.db.QueryRowContext(ctx, getPlanByName, name)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BillingCycle,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPlanFeaturesByPlanID = `-- name: GetPlanFeaturesByPlanID :many
SELECT id, plan_id, name, description, value, created_at, updated_at, deleted_at FROM plan_features
WHERE plan_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPlanFeaturesByPlanID(ctx context.Context, planID uuid.UUID) ([]PlanFeature, error) {
	rows, err := q.db.QueryContext(ctx, getPlanFeaturesByPlanID, planID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PlanFeature{}
	for rows.Next() {
		var i PlanFeature
		if err := rows.Scan(
			&i.ID,
			&i.PlanID,
			&i.Name,
			&i.Description,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanWithDetails = `-- name: GetPlanWithDetails :one
SELECT 
    p.id, p.name, p.description, p.price, p.billing_cycle, p.status, p.created_at, p.updated_at, p.deleted_at,
    (
        SELECT json_agg(pf.*)
        FROM plan_features pf
        WHERE pf.plan_id = p.id AND pf.deleted_at IS NULL
    ) as features,
    ml.daily_limit,
    ml.monthly_limit,
    ml.max_recipients_per_mail
FROM plans p
LEFT JOIN mailing_limits ml ON p.id = ml.plan_id AND ml.deleted_at IS NULL
WHERE p.id = $1 AND p.deleted_at IS NULL
`

type GetPlanWithDetailsRow struct {
	ID                   uuid.UUID       `json:"id"`
	Name                 string          `json:"name"`
	Description          sql.NullString  `json:"description"`
	Price                decimal.Decimal `json:"price"`
	BillingCycle         sql.NullString  `json:"billing_cycle"`
	Status               sql.NullString  `json:"status"`
	CreatedAt            time.Time       `json:"created_at"`
	UpdatedAt            time.Time       `json:"updated_at"`
	DeletedAt            sql.NullTime    `json:"deleted_at"`
	Features             json.RawMessage `json:"features"`
	DailyLimit           sql.NullInt32   `json:"daily_limit"`
	MonthlyLimit         sql.NullInt32   `json:"monthly_limit"`
	MaxRecipientsPerMail sql.NullInt32   `json:"max_recipients_per_mail"`
}

func (q *Queries) GetPlanWithDetails(ctx context.Context, id uuid.UUID) (GetPlanWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getPlanWithDetails, id)
	var i GetPlanWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BillingCycle,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Features,
		&i.DailyLimit,
		&i.MonthlyLimit,
		&i.MaxRecipientsPerMail,
	)
	return i, err
}

const listActivePlans = `-- name: ListActivePlans :many
SELECT id, name, description, price, billing_cycle, status, created_at, updated_at, deleted_at FROM plans
WHERE status = 'active' AND deleted_at IS NULL
ORDER BY price ASC
`

func (q *Queries) ListActivePlans(ctx context.Context) ([]Plan, error) {
	rows, err := q.db.QueryContext(ctx, listActivePlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.BillingCycle,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlansWithDetails = `-- name: ListPlansWithDetails :many
SELECT 
    p.id, p.name, p.description, p.price, p.billing_cycle, p.status, p.created_at, p.updated_at, p.deleted_at,
    (
        SELECT json_agg(pf.*)
        FROM plan_features pf
        WHERE pf.plan_id = p.id AND pf.deleted_at IS NULL
    ) as features,
    ml.daily_limit,
    ml.monthly_limit,
    ml.max_recipients_per_mail,
    (
        SELECT COUNT(*)
        FROM subscriptions s
        WHERE s.plan_id = p.id AND s.status = 'active' AND s.deleted_at IS NULL
    ) as active_subscriptions_count
FROM plans p
LEFT JOIN mailing_limits ml ON p.id = ml.plan_id AND ml.deleted_at IS NULL
WHERE p.deleted_at IS NULL
ORDER BY p.price ASC
`

type ListPlansWithDetailsRow struct {
	ID                       uuid.UUID       `json:"id"`
	Name                     string          `json:"name"`
	Description              sql.NullString  `json:"description"`
	Price                    decimal.Decimal `json:"price"`
	BillingCycle             sql.NullString  `json:"billing_cycle"`
	Status                   sql.NullString  `json:"status"`
	CreatedAt                time.Time       `json:"created_at"`
	UpdatedAt                time.Time       `json:"updated_at"`
	DeletedAt                sql.NullTime    `json:"deleted_at"`
	Features                 json.RawMessage `json:"features"`
	DailyLimit               sql.NullInt32   `json:"daily_limit"`
	MonthlyLimit             sql.NullInt32   `json:"monthly_limit"`
	MaxRecipientsPerMail     sql.NullInt32   `json:"max_recipients_per_mail"`
	ActiveSubscriptionsCount int64           `json:"active_subscriptions_count"`
}

func (q *Queries) ListPlansWithDetails(ctx context.Context) ([]ListPlansWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlansWithDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlansWithDetailsRow{}
	for rows.Next() {
		var i ListPlansWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.BillingCycle,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Features,
			&i.DailyLimit,
			&i.MonthlyLimit,
			&i.MaxRecipientsPerMail,
			&i.ActiveSubscriptionsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const planExists = `-- name: PlanExists :one
SELECT EXISTS(SELECT 1 FROM plans WHERE name = $1)
`

func (q *Queries) PlanExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, planExists, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const softDeletePlan = `-- name: SoftDeletePlan :exec
UPDATE plans
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeletePlan(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeletePlan, id)
	return err
}

const updateMailingLimit = `-- name: UpdateMailingLimit :one
UPDATE mailing_limits
SET 
    daily_limit = COALESCE($1, daily_limit),
    monthly_limit = COALESCE($2, monthly_limit),
    max_recipients_per_mail = COALESCE($3, max_recipients_per_mail),
    updated_at = CURRENT_TIMESTAMP
WHERE plan_id = $4 AND deleted_at IS NULL
RETURNING id, plan_id, daily_limit, monthly_limit, max_recipients_per_mail, created_at, updated_at, deleted_at
`

type UpdateMailingLimitParams struct {
	DailyLimit           sql.NullInt32 `json:"daily_limit"`
	MonthlyLimit         sql.NullInt32 `json:"monthly_limit"`
	MaxRecipientsPerMail sql.NullInt32 `json:"max_recipients_per_mail"`
	PlanID               uuid.UUID     `json:"plan_id"`
}

func (q *Queries) UpdateMailingLimit(ctx context.Context, arg UpdateMailingLimitParams) (MailingLimit, error) {
	row := q.db.QueryRowContext(ctx, updateMailingLimit,
		arg.DailyLimit,
		arg.MonthlyLimit,
		arg.MaxRecipientsPerMail,
		arg.PlanID,
	)
	var i MailingLimit
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.DailyLimit,
		&i.MonthlyLimit,
		&i.MaxRecipientsPerMail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePlan = `-- name: UpdatePlan :one
UPDATE plans
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    price = COALESCE($3, price),
    billing_cycle = COALESCE($4, billing_cycle),
    status = COALESCE($5, status),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6 AND deleted_at IS NULL
RETURNING id, name, description, price, billing_cycle, status, created_at, updated_at, deleted_at
`

type UpdatePlanParams struct {
	Name         string          `json:"name"`
	Description  sql.NullString  `json:"description"`
	Price        decimal.Decimal `json:"price"`
	BillingCycle sql.NullString  `json:"billing_cycle"`
	Status       sql.NullString  `json:"status"`
	ID           uuid.UUID       `json:"id"`
}

func (q *Queries) UpdatePlan(ctx context.Context, arg UpdatePlanParams) (Plan, error) {
	row := q.db.QueryRowContext(ctx, updatePlan,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.BillingCycle,
		arg.Status,
		arg.ID,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BillingCycle,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePlanFeature = `-- name: UpdatePlanFeature :one
UPDATE plan_features
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    value = COALESCE($3, value),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, plan_id, name, description, value, created_at, updated_at, deleted_at
`

type UpdatePlanFeatureParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Value       sql.NullString `json:"value"`
	ID          uuid.UUID      `json:"id"`
}

func (q *Queries) UpdatePlanFeature(ctx context.Context, arg UpdatePlanFeatureParams) (PlanFeature, error) {
	row := q.db.QueryRowContext(ctx, updatePlanFeature,
		arg.Name,
		arg.Description,
		arg.Value,
		arg.ID,
	)
	var i PlanFeature
	err := row.Scan(
		&i.ID,
		&i.PlanID,
		&i.Name,
		&i.Description,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
