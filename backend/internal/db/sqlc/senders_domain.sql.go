// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: senders_domain.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkDomainExists = `-- name: CheckDomainExists :one
SELECT EXISTS (
        SELECT 1
        FROM domains
        WHERE
            domain = $1
            and company_id = $2
            AND deleted_at is NULL
    ) AS exists
`

type CheckDomainExistsParams struct {
	Domain    string    `json:"domain"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) CheckDomainExists(ctx context.Context, arg CheckDomainExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkDomainExists, arg.Domain, arg.CompanyID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSenderExists = `-- name: CheckSenderExists :one
SELECT EXISTS (
        SELECT 1
        FROM senders
        WHERE
            email = $1
            AND name = $2
            AND company_id = $3
            AND deleted_at IS NULL
    ) AS exists
`

type CheckSenderExistsParams struct {
	Email     string    `json:"email"`
	Name      string    `json:"name"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) CheckSenderExists(ctx context.Context, arg CheckSenderExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSenderExists, arg.Email, arg.Name, arg.CompanyID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countDomainByCompanyID = `-- name: CountDomainByCompanyID :one
SELECT COUNT(*)
FROM domains
WHERE
    company_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) CountDomainByCompanyID(ctx context.Context, companyID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDomainByCompanyID, companyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSenderByCompanyID = `-- name: CountSenderByCompanyID :one
SELECT COUNT(*)
FROM senders
WHERE
    company_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) CountSenderByCompanyID(ctx context.Context, companyID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSenderByCompanyID, companyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDomain = `-- name: CreateDomain :one
INSERT INTO
    domains (
        user_id,
        company_id,
        domain,
        txt_record,
        dmarc_record,
        dkim_selector,
        dkim_public_key,
        dkim_private_key,
        spf_record,
        verified,
        mx_record
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    ) RETURNING id, user_id, company_id, domain, txt_record, dmarc_record, dkim_selector, dkim_public_key, dkim_private_key, spf_record, verified, mx_record, created_at, updated_at, deleted_at
`

type CreateDomainParams struct {
	UserID         uuid.UUID      `json:"user_id"`
	CompanyID      uuid.UUID      `json:"company_id"`
	Domain         string         `json:"domain"`
	TxtRecord      sql.NullString `json:"txt_record"`
	DmarcRecord    sql.NullString `json:"dmarc_record"`
	DkimSelector   sql.NullString `json:"dkim_selector"`
	DkimPublicKey  sql.NullString `json:"dkim_public_key"`
	DkimPrivateKey sql.NullString `json:"dkim_private_key"`
	SpfRecord      sql.NullString `json:"spf_record"`
	Verified       sql.NullBool   `json:"verified"`
	MxRecord       sql.NullString `json:"mx_record"`
}

func (q *Queries) CreateDomain(ctx context.Context, arg CreateDomainParams) (Domain, error) {
	row := q.db.QueryRowContext(ctx, createDomain,
		arg.UserID,
		arg.CompanyID,
		arg.Domain,
		arg.TxtRecord,
		arg.DmarcRecord,
		arg.DkimSelector,
		arg.DkimPublicKey,
		arg.DkimPrivateKey,
		arg.SpfRecord,
		arg.Verified,
		arg.MxRecord,
	)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Domain,
		&i.TxtRecord,
		&i.DmarcRecord,
		&i.DkimSelector,
		&i.DkimPublicKey,
		&i.DkimPrivateKey,
		&i.SpfRecord,
		&i.Verified,
		&i.MxRecord,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSender = `-- name: CreateSender :one
INSERT INTO
    senders (
        user_id,
        company_id,
        name,
        email,
        verified,
        is_signed,
        domain_id
    )
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, user_id, company_id, name, email, verified, is_signed, domain_id, created_at, updated_at, deleted_at
`

type CreateSenderParams struct {
	UserID    uuid.UUID     `json:"user_id"`
	CompanyID uuid.UUID     `json:"company_id"`
	Name      string        `json:"name"`
	Email     string        `json:"email"`
	Verified  sql.NullBool  `json:"verified"`
	IsSigned  sql.NullBool  `json:"is_signed"`
	DomainID  uuid.NullUUID `json:"domain_id"`
}

func (q *Queries) CreateSender(ctx context.Context, arg CreateSenderParams) (Sender, error) {
	row := q.db.QueryRowContext(ctx, createSender,
		arg.UserID,
		arg.CompanyID,
		arg.Name,
		arg.Email,
		arg.Verified,
		arg.IsSigned,
		arg.DomainID,
	)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Name,
		&i.Email,
		&i.Verified,
		&i.IsSigned,
		&i.DomainID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findDomainByNameAndCompany = `-- name: FindDomainByNameAndCompany :one
SELECT id, user_id, company_id, domain, txt_record, dmarc_record, dkim_selector, dkim_public_key, dkim_private_key, spf_record, verified, mx_record, created_at, updated_at, deleted_at
FROM domains
WHERE
    domain = $1
    AND company_id = $2
    AND deleted_at IS NULL
`

type FindDomainByNameAndCompanyParams struct {
	Domain    string    `json:"domain"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) FindDomainByNameAndCompany(ctx context.Context, arg FindDomainByNameAndCompanyParams) (Domain, error) {
	row := q.db.QueryRowContext(ctx, findDomainByNameAndCompany, arg.Domain, arg.CompanyID)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Domain,
		&i.TxtRecord,
		&i.DmarcRecord,
		&i.DkimSelector,
		&i.DkimPublicKey,
		&i.DkimPrivateKey,
		&i.SpfRecord,
		&i.Verified,
		&i.MxRecord,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDomainByIDAndCompany = `-- name: GetDomainByIDAndCompany :one
SELECT id, user_id, company_id, domain, txt_record, dmarc_record, dkim_selector, dkim_public_key, dkim_private_key, spf_record, verified, mx_record, created_at, updated_at, deleted_at
FROM domains
WHERE
    id = $1
    AND company_id = $2
    AND deleted_at IS NULL
`

type GetDomainByIDAndCompanyParams struct {
	ID        uuid.UUID `json:"id"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) GetDomainByIDAndCompany(ctx context.Context, arg GetDomainByIDAndCompanyParams) (Domain, error) {
	row := q.db.QueryRowContext(ctx, getDomainByIDAndCompany, arg.ID, arg.CompanyID)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Domain,
		&i.TxtRecord,
		&i.DmarcRecord,
		&i.DkimSelector,
		&i.DkimPublicKey,
		&i.DkimPrivateKey,
		&i.SpfRecord,
		&i.Verified,
		&i.MxRecord,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSenderById = `-- name: GetSenderById :one
SELECT id, user_id, company_id, name, email, verified, is_signed, domain_id, created_at, updated_at, deleted_at
FROM senders
WHERE
    company_id = $1
    AND id = $2
    AND deleted_at IS NULL
`

type GetSenderByIdParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) GetSenderById(ctx context.Context, arg GetSenderByIdParams) (Sender, error) {
	row := q.db.QueryRowContext(ctx, getSenderById, arg.CompanyID, arg.ID)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Name,
		&i.Email,
		&i.Verified,
		&i.IsSigned,
		&i.DomainID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listDomainsByCompany = `-- name: ListDomainsByCompany :many
SELECT id, user_id, company_id, domain, txt_record, dmarc_record, dkim_selector, dkim_public_key, dkim_private_key, spf_record, verified, mx_record, created_at, updated_at, deleted_at
FROM domains
WHERE
    company_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3
OFFSET
    $2
`

type ListDomainsByCompanyParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	Rowoffset int32     `json:"rowoffset"`
	Rowlimit  int32     `json:"rowlimit"`
}

func (q *Queries) ListDomainsByCompany(ctx context.Context, arg ListDomainsByCompanyParams) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, listDomainsByCompany, arg.CompanyID, arg.Rowoffset, arg.Rowlimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domain{}
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Domain,
			&i.TxtRecord,
			&i.DmarcRecord,
			&i.DkimSelector,
			&i.DkimPublicKey,
			&i.DkimPrivateKey,
			&i.SpfRecord,
			&i.Verified,
			&i.MxRecord,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSendersByCompanyId = `-- name: ListSendersByCompanyId :many
SELECT id, user_id, company_id, name, email, verified, is_signed, domain_id, created_at, updated_at, deleted_at
FROM senders
WHERE
    company_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
OFFSET
    $3
`

type ListSendersByCompanyIdParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListSendersByCompanyId(ctx context.Context, arg ListSendersByCompanyIdParams) ([]Sender, error) {
	rows, err := q.db.QueryContext(ctx, listSendersByCompanyId, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sender{}
	for rows.Next() {
		var i Sender
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Name,
			&i.Email,
			&i.Verified,
			&i.IsSigned,
			&i.DomainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteDomain = `-- name: SoftDeleteDomain :exec
UPDATE domains
SET
    deleted_at = now(),
    updated_at = now()
WHERE
    company_id = $1
    AND id = $2
`

type SoftDeleteDomainParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) SoftDeleteDomain(ctx context.Context, arg SoftDeleteDomainParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteDomain, arg.CompanyID, arg.ID)
	return err
}

const softDeleteSender = `-- name: SoftDeleteSender :exec
UPDATE senders
SET
    deleted_at = now(),
    updated_at = now()
WHERE
    id = $1
    AND company_id = $2
`

type SoftDeleteSenderParams struct {
	ID        uuid.UUID `json:"id"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) SoftDeleteSender(ctx context.Context, arg SoftDeleteSenderParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteSender, arg.ID, arg.CompanyID)
	return err
}

const updateDomain = `-- name: UpdateDomain :exec
UPDATE domains
SET
    domain = COALESCE($1, domain),
    txt_record = COALESCE($2, txt_record),
    dmarc_record = COALESCE($3, dmarc_record),
    dkim_selector = COALESCE($4, dkim_selector),
    dkim_public_key = COALESCE(
        $5,
        dkim_public_key
    ),
    dkim_private_key = COALESCE(
        $6,
        dkim_private_key
    ),
    spf_record = COALESCE($7, spf_record),
    verified = COALESCE($8, verified),
    mx_record = COALESCE($9, mx_record),
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $10
    AND company_id = $11
`

type UpdateDomainParams struct {
	Domain         string         `json:"domain"`
	TxtRecord      sql.NullString `json:"txt_record"`
	DmarcRecord    sql.NullString `json:"dmarc_record"`
	DkimSelector   sql.NullString `json:"dkim_selector"`
	DkimPublicKey  sql.NullString `json:"dkim_public_key"`
	DkimPrivateKey sql.NullString `json:"dkim_private_key"`
	SpfRecord      sql.NullString `json:"spf_record"`
	Verified       sql.NullBool   `json:"verified"`
	MxRecord       sql.NullString `json:"mx_record"`
	ID             uuid.UUID      `json:"id"`
	CompanyID      uuid.UUID      `json:"company_id"`
}

func (q *Queries) UpdateDomain(ctx context.Context, arg UpdateDomainParams) error {
	_, err := q.db.ExecContext(ctx, updateDomain,
		arg.Domain,
		arg.TxtRecord,
		arg.DmarcRecord,
		arg.DkimSelector,
		arg.DkimPublicKey,
		arg.DkimPrivateKey,
		arg.SpfRecord,
		arg.Verified,
		arg.MxRecord,
		arg.ID,
		arg.CompanyID,
	)
	return err
}

const updateSender = `-- name: UpdateSender :one
UPDATE senders
SET
    user_id = COALESCE($3, user_id),
    name = COALESCE($4, name),
    email = COALESCE($5, email),
    verified = COALESCE($6, verified),
    is_signed = COALESCE($7, is_signed),
    domain_id = COALESCE($8, domain_id),
    updated_at = NOW()
WHERE
    id = $1
    AND company_id = $2 RETURNING id, user_id, company_id, name, email, verified, is_signed, domain_id, created_at, updated_at, deleted_at
`

type UpdateSenderParams struct {
	ID        uuid.UUID     `json:"id"`
	CompanyID uuid.UUID     `json:"company_id"`
	UserID    uuid.UUID     `json:"user_id"`
	Name      string        `json:"name"`
	Email     string        `json:"email"`
	Verified  sql.NullBool  `json:"verified"`
	IsSigned  sql.NullBool  `json:"is_signed"`
	DomainID  uuid.NullUUID `json:"domain_id"`
}

func (q *Queries) UpdateSender(ctx context.Context, arg UpdateSenderParams) (Sender, error) {
	row := q.db.QueryRowContext(ctx, updateSender,
		arg.ID,
		arg.CompanyID,
		arg.UserID,
		arg.Name,
		arg.Email,
		arg.Verified,
		arg.IsSigned,
		arg.DomainID,
	)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Name,
		&i.Email,
		&i.Verified,
		&i.IsSigned,
		&i.DomainID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSenderVerified = `-- name: UpdateSenderVerified :exec
UPDATE senders
SET
    verified = $1,
    updated_at = NOW()
WHERE
    company_id = $2
    AND email = $3
`

type UpdateSenderVerifiedParams struct {
	Verified  sql.NullBool `json:"verified"`
	CompanyID uuid.UUID    `json:"company_id"`
	Email     string       `json:"email"`
}

func (q *Queries) UpdateSenderVerified(ctx context.Context, arg UpdateSenderVerifiedParams) error {
	_, err := q.db.ExecContext(ctx, updateSenderVerified, arg.Verified, arg.CompanyID, arg.Email)
	return err
}
