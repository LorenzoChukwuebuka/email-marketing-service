// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payment_intent.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/shopspring/decimal"
	"github.com/sqlc-dev/pqtype"
)

const createPaymentIntent = `-- name: CreatePaymentIntent :one
INSERT INTO
    payment_intents (
        company_id,
        user_id,
        subscription_id,
        payment_intent_id,
        amount,
        currency,
        payment_method_types,
        status,
        client_secret,
        description,
        metadata,
        automatic_payment_methods,
        receipt_email,
        setup_future_usage,
        confirmation_method,
        capture_method,
        payment_method_id,
        last_payment_error,
        next_action,
        canceled_at,
        succeeded_at,
        expires_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20,
        $21,
        $22
    ) RETURNING id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
`

type CreatePaymentIntentParams struct {
	CompanyID               uuid.UUID             `json:"company_id"`
	UserID                  uuid.UUID             `json:"user_id"`
	SubscriptionID          uuid.NullUUID         `json:"subscription_id"`
	PaymentIntentID         string                `json:"payment_intent_id"`
	Amount                  decimal.Decimal       `json:"amount"`
	Currency                sql.NullString        `json:"currency"`
	PaymentMethodTypes      []string              `json:"payment_method_types"`
	Status                  sql.NullString        `json:"status"`
	ClientSecret            sql.NullString        `json:"client_secret"`
	Description             sql.NullString        `json:"description"`
	Metadata                pqtype.NullRawMessage `json:"metadata"`
	AutomaticPaymentMethods sql.NullBool          `json:"automatic_payment_methods"`
	ReceiptEmail            sql.NullString        `json:"receipt_email"`
	SetupFutureUsage        sql.NullString        `json:"setup_future_usage"`
	ConfirmationMethod      sql.NullString        `json:"confirmation_method"`
	CaptureMethod           sql.NullString        `json:"capture_method"`
	PaymentMethodID         sql.NullString        `json:"payment_method_id"`
	LastPaymentError        pqtype.NullRawMessage `json:"last_payment_error"`
	NextAction              pqtype.NullRawMessage `json:"next_action"`
	CanceledAt              sql.NullTime          `json:"canceled_at"`
	SucceededAt             sql.NullTime          `json:"succeeded_at"`
	ExpiresAt               sql.NullTime          `json:"expires_at"`
}

func (q *Queries) CreatePaymentIntent(ctx context.Context, arg CreatePaymentIntentParams) (PaymentIntent, error) {
	row := q.db.QueryRowContext(ctx, createPaymentIntent,
		arg.CompanyID,
		arg.UserID,
		arg.SubscriptionID,
		arg.PaymentIntentID,
		arg.Amount,
		arg.Currency,
		pq.Array(arg.PaymentMethodTypes),
		arg.Status,
		arg.ClientSecret,
		arg.Description,
		arg.Metadata,
		arg.AutomaticPaymentMethods,
		arg.ReceiptEmail,
		arg.SetupFutureUsage,
		arg.ConfirmationMethod,
		arg.CaptureMethod,
		arg.PaymentMethodID,
		arg.LastPaymentError,
		arg.NextAction,
		arg.CanceledAt,
		arg.SucceededAt,
		arg.ExpiresAt,
	)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentIntentID,
		&i.Amount,
		&i.Currency,
		pq.Array(&i.PaymentMethodTypes),
		&i.Status,
		&i.ClientSecret,
		&i.Description,
		&i.Metadata,
		&i.AutomaticPaymentMethods,
		&i.ReceiptEmail,
		&i.SetupFutureUsage,
		&i.ConfirmationMethod,
		&i.CaptureMethod,
		&i.PaymentMethodID,
		&i.LastPaymentError,
		&i.NextAction,
		&i.CanceledAt,
		&i.SucceededAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentIntent = `-- name: GetPaymentIntent :one
SELECT id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at FROM payment_intents WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentIntent(ctx context.Context, id uuid.UUID) (PaymentIntent, error) {
	row := q.db.QueryRowContext(ctx, getPaymentIntent, id)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentIntentID,
		&i.Amount,
		&i.Currency,
		pq.Array(&i.PaymentMethodTypes),
		&i.Status,
		&i.ClientSecret,
		&i.Description,
		&i.Metadata,
		&i.AutomaticPaymentMethods,
		&i.ReceiptEmail,
		&i.SetupFutureUsage,
		&i.ConfirmationMethod,
		&i.CaptureMethod,
		&i.PaymentMethodID,
		&i.LastPaymentError,
		&i.NextAction,
		&i.CanceledAt,
		&i.SucceededAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentIntentByPaymentIntentID = `-- name: GetPaymentIntentByPaymentIntentID :one
SELECT id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
FROM payment_intents
WHERE
    payment_intent_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetPaymentIntentByPaymentIntentID(ctx context.Context, paymentIntentID string) (PaymentIntent, error) {
	row := q.db.QueryRowContext(ctx, getPaymentIntentByPaymentIntentID, paymentIntentID)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentIntentID,
		&i.Amount,
		&i.Currency,
		pq.Array(&i.PaymentMethodTypes),
		&i.Status,
		&i.ClientSecret,
		&i.Description,
		&i.Metadata,
		&i.AutomaticPaymentMethods,
		&i.ReceiptEmail,
		&i.SetupFutureUsage,
		&i.ConfirmationMethod,
		&i.CaptureMethod,
		&i.PaymentMethodID,
		&i.LastPaymentError,
		&i.NextAction,
		&i.CanceledAt,
		&i.SucceededAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentIntentsByCompanyID = `-- name: GetPaymentIntentsByCompanyID :many
SELECT id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
FROM payment_intents
WHERE
    company_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetPaymentIntentsByCompanyID(ctx context.Context, companyID uuid.UUID) ([]PaymentIntent, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentIntentsByCompanyID, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentIntent{}
	for rows.Next() {
		var i PaymentIntent
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Currency,
			pq.Array(&i.PaymentMethodTypes),
			&i.Status,
			&i.ClientSecret,
			&i.Description,
			&i.Metadata,
			&i.AutomaticPaymentMethods,
			&i.ReceiptEmail,
			&i.SetupFutureUsage,
			&i.ConfirmationMethod,
			&i.CaptureMethod,
			&i.PaymentMethodID,
			&i.LastPaymentError,
			&i.NextAction,
			&i.CanceledAt,
			&i.SucceededAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentIntentsByStatus = `-- name: GetPaymentIntentsByStatus :many
SELECT id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
FROM payment_intents
WHERE
    company_id = $1
    AND status = $2
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetPaymentIntentsByStatusParams struct {
	CompanyID uuid.UUID      `json:"company_id"`
	Status    sql.NullString `json:"status"`
}

func (q *Queries) GetPaymentIntentsByStatus(ctx context.Context, arg GetPaymentIntentsByStatusParams) ([]PaymentIntent, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentIntentsByStatus, arg.CompanyID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentIntent{}
	for rows.Next() {
		var i PaymentIntent
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Currency,
			pq.Array(&i.PaymentMethodTypes),
			&i.Status,
			&i.ClientSecret,
			&i.Description,
			&i.Metadata,
			&i.AutomaticPaymentMethods,
			&i.ReceiptEmail,
			&i.SetupFutureUsage,
			&i.ConfirmationMethod,
			&i.CaptureMethod,
			&i.PaymentMethodID,
			&i.LastPaymentError,
			&i.NextAction,
			&i.CanceledAt,
			&i.SucceededAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentIntentsBySubscriptionID = `-- name: GetPaymentIntentsBySubscriptionID :many
SELECT id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
FROM payment_intents
WHERE
    subscription_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetPaymentIntentsBySubscriptionID(ctx context.Context, subscriptionID uuid.NullUUID) ([]PaymentIntent, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentIntentsBySubscriptionID, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentIntent{}
	for rows.Next() {
		var i PaymentIntent
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Currency,
			pq.Array(&i.PaymentMethodTypes),
			&i.Status,
			&i.ClientSecret,
			&i.Description,
			&i.Metadata,
			&i.AutomaticPaymentMethods,
			&i.ReceiptEmail,
			&i.SetupFutureUsage,
			&i.ConfirmationMethod,
			&i.CaptureMethod,
			&i.PaymentMethodID,
			&i.LastPaymentError,
			&i.NextAction,
			&i.CanceledAt,
			&i.SucceededAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentIntentsByUserID = `-- name: GetPaymentIntentsByUserID :many
SELECT id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
FROM payment_intents
WHERE
    user_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetPaymentIntentsByUserID(ctx context.Context, userID uuid.UUID) ([]PaymentIntent, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentIntentsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentIntent{}
	for rows.Next() {
		var i PaymentIntent
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.SubscriptionID,
			&i.PaymentIntentID,
			&i.Amount,
			&i.Currency,
			pq.Array(&i.PaymentMethodTypes),
			&i.Status,
			&i.ClientSecret,
			&i.Description,
			&i.Metadata,
			&i.AutomaticPaymentMethods,
			&i.ReceiptEmail,
			&i.SetupFutureUsage,
			&i.ConfirmationMethod,
			&i.CaptureMethod,
			&i.PaymentMethodID,
			&i.LastPaymentError,
			&i.NextAction,
			&i.CanceledAt,
			&i.SucceededAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentIntent = `-- name: UpdatePaymentIntent :one
UPDATE payment_intents
SET
    subscription_id = COALESCE(
        $1,
        subscription_id
    ),
    amount = COALESCE($2, amount),
    currency = COALESCE(
        $3,
        currency
    ),
    payment_method_types = COALESCE(
        $4,
        payment_method_types
    ),
    payment_intent_id = COALESCE(
        $5,
        payment_intent_id
    ),
    status = COALESCE($6, status),
    client_secret = COALESCE(
        $7,
        client_secret
    ),
    description = COALESCE(
        $8,
        description
    ),
    metadata = COALESCE(
        $9,
        metadata
    ),
    automatic_payment_methods = COALESCE(
        $10,
        automatic_payment_methods
    ),
    receipt_email = COALESCE(
        $11,
        receipt_email
    ),
    setup_future_usage = COALESCE(
        $12,
        setup_future_usage
    ),
    confirmation_method = COALESCE(
        $13,
        confirmation_method
    ),
    capture_method = COALESCE(
        $14,
        capture_method
    ),
    payment_method_id = COALESCE(
        $15,
        payment_method_id
    ),
    last_payment_error = COALESCE(
        $16,
        last_payment_error
    ),
    next_action = COALESCE(
        $17,
        next_action
    ),
    canceled_at = COALESCE(
        $18,
        canceled_at
    ),
    succeeded_at = COALESCE(
        $19,
        succeeded_at
    ),
    expires_at = COALESCE(
        $20,
        expires_at
    ),
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $21
    AND deleted_at IS NULL RETURNING id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
`

type UpdatePaymentIntentParams struct {
	SubscriptionID          uuid.NullUUID         `json:"subscription_id"`
	Amount                  decimal.Decimal       `json:"amount"`
	Currency                sql.NullString        `json:"currency"`
	PaymentMethodTypes      []string              `json:"payment_method_types"`
	PaymentIntentID         sql.NullString        `json:"payment_intent_id"`
	Status                  sql.NullString        `json:"status"`
	ClientSecret            sql.NullString        `json:"client_secret"`
	Description             sql.NullString        `json:"description"`
	Metadata                pqtype.NullRawMessage `json:"metadata"`
	AutomaticPaymentMethods sql.NullBool          `json:"automatic_payment_methods"`
	ReceiptEmail            sql.NullString        `json:"receipt_email"`
	SetupFutureUsage        sql.NullString        `json:"setup_future_usage"`
	ConfirmationMethod      sql.NullString        `json:"confirmation_method"`
	CaptureMethod           sql.NullString        `json:"capture_method"`
	PaymentMethodID         sql.NullString        `json:"payment_method_id"`
	LastPaymentError        pqtype.NullRawMessage `json:"last_payment_error"`
	NextAction              pqtype.NullRawMessage `json:"next_action"`
	CanceledAt              sql.NullTime          `json:"canceled_at"`
	SucceededAt             sql.NullTime          `json:"succeeded_at"`
	ExpiresAt               sql.NullTime          `json:"expires_at"`
	ID                      uuid.UUID             `json:"id"`
}

func (q *Queries) UpdatePaymentIntent(ctx context.Context, arg UpdatePaymentIntentParams) (PaymentIntent, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentIntent,
		arg.SubscriptionID,
		arg.Amount,
		arg.Currency,
		pq.Array(arg.PaymentMethodTypes),
		arg.PaymentIntentID,
		arg.Status,
		arg.ClientSecret,
		arg.Description,
		arg.Metadata,
		arg.AutomaticPaymentMethods,
		arg.ReceiptEmail,
		arg.SetupFutureUsage,
		arg.ConfirmationMethod,
		arg.CaptureMethod,
		arg.PaymentMethodID,
		arg.LastPaymentError,
		arg.NextAction,
		arg.CanceledAt,
		arg.SucceededAt,
		arg.ExpiresAt,
		arg.ID,
	)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentIntentID,
		&i.Amount,
		&i.Currency,
		pq.Array(&i.PaymentMethodTypes),
		&i.Status,
		&i.ClientSecret,
		&i.Description,
		&i.Metadata,
		&i.AutomaticPaymentMethods,
		&i.ReceiptEmail,
		&i.SetupFutureUsage,
		&i.ConfirmationMethod,
		&i.CaptureMethod,
		&i.PaymentMethodID,
		&i.LastPaymentError,
		&i.NextAction,
		&i.CanceledAt,
		&i.SucceededAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePaymentIntentError = `-- name: UpdatePaymentIntentError :one
UPDATE payment_intents
SET
    last_payment_error = $1,
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE
    payment_intent_id = $3
    AND deleted_at IS NULL RETURNING id, company_id, user_id, subscription_id, payment_intent_id, amount, currency, payment_method_types, status, client_secret, description, metadata, automatic_payment_methods, receipt_email, setup_future_usage, confirmation_method, capture_method, payment_method_id, last_payment_error, next_action, canceled_at, succeeded_at, expires_at, created_at, updated_at, deleted_at
`

type UpdatePaymentIntentErrorParams struct {
	LastPaymentError pqtype.NullRawMessage `json:"last_payment_error"`
	Status           sql.NullString        `json:"status"`
	PaymentIntentID  string                `json:"payment_intent_id"`
}

func (q *Queries) UpdatePaymentIntentError(ctx context.Context, arg UpdatePaymentIntentErrorParams) (PaymentIntent, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentIntentError, arg.LastPaymentError, arg.Status, arg.PaymentIntentID)
	var i PaymentIntent
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.SubscriptionID,
		&i.PaymentIntentID,
		&i.Amount,
		&i.Currency,
		pq.Array(&i.PaymentMethodTypes),
		&i.Status,
		&i.ClientSecret,
		&i.Description,
		&i.Metadata,
		&i.AutomaticPaymentMethods,
		&i.ReceiptEmail,
		&i.SetupFutureUsage,
		&i.ConfirmationMethod,
		&i.CaptureMethod,
		&i.PaymentMethodID,
		&i.LastPaymentError,
		&i.NextAction,
		&i.CanceledAt,
		&i.SucceededAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
