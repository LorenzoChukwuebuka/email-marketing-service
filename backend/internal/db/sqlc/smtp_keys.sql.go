// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: smtp_keys.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const checkSMTPKeyExists = `-- name: CheckSMTPKeyExists :one
SELECT EXISTS (
        SELECT 1
        FROM smtp_keys
        WHERE
            key_name = $1
            AND password = $2
            AND deleted_at IS NULL
    ) AS exists
`

type CheckSMTPKeyExistsParams struct {
	KeyName  string `json:"key_name"`
	Password string `json:"password"`
}

func (q *Queries) CheckSMTPKeyExists(ctx context.Context, arg CheckSMTPKeyExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSMTPKeyExists, arg.KeyName, arg.Password)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createSMTPKey = `-- name: CreateSMTPKey :one
INSERT INTO
    smtp_keys (
        company_id,
        user_id,
        key_name,
        password,
        status,
        smtp_login
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, company_id, user_id, key_name, password, status, smtp_login, created_at, updated_at, deleted_at
`

type CreateSMTPKeyParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	UserID    uuid.UUID `json:"user_id"`
	KeyName   string    `json:"key_name"`
	Password  string    `json:"password"`
	Status    string    `json:"status"`
	SmtpLogin string    `json:"smtp_login"`
}

func (q *Queries) CreateSMTPKey(ctx context.Context, arg CreateSMTPKeyParams) (SmtpKey, error) {
	row := q.db.QueryRowContext(ctx, createSMTPKey,
		arg.CompanyID,
		arg.UserID,
		arg.KeyName,
		arg.Password,
		arg.Status,
		arg.SmtpLogin,
	)
	var i SmtpKey
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.KeyName,
		&i.Password,
		&i.Status,
		&i.SmtpLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSMTPKeyByID = `-- name: GetSMTPKeyByID :one
SELECT id, company_id, user_id, key_name, password, status, smtp_login, created_at, updated_at, deleted_at FROM smtp_keys WHERE user_id = $1 AND id = $2 LIMIT 1
`

type GetSMTPKeyByIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) GetSMTPKeyByID(ctx context.Context, arg GetSMTPKeyByIDParams) (SmtpKey, error) {
	row := q.db.QueryRowContext(ctx, getSMTPKeyByID, arg.UserID, arg.ID)
	var i SmtpKey
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.KeyName,
		&i.Password,
		&i.Status,
		&i.SmtpLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSMTPKeyUserAndPass = `-- name: GetSMTPKeyUserAndPass :one
SELECT id, company_id, user_id, key_name, password, status, smtp_login, created_at, updated_at, deleted_at
FROM smtp_keys
WHERE
    key_name = $1
    AND password = $2
    AND deleted_at IS NULL
LIMIT 1
`

type GetSMTPKeyUserAndPassParams struct {
	KeyName  string `json:"key_name"`
	Password string `json:"password"`
}

func (q *Queries) GetSMTPKeyUserAndPass(ctx context.Context, arg GetSMTPKeyUserAndPassParams) (SmtpKey, error) {
	row := q.db.QueryRowContext(ctx, getSMTPKeyUserAndPass, arg.KeyName, arg.Password)
	var i SmtpKey
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.KeyName,
		&i.Password,
		&i.Status,
		&i.SmtpLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserSMTPKey = `-- name: GetUserSMTPKey :many
SELECT id, company_id, user_id, key_name, password, status, smtp_login, created_at, updated_at, deleted_at FROM smtp_keys WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserSMTPKey(ctx context.Context, userID uuid.UUID) ([]SmtpKey, error) {
	rows, err := q.db.QueryContext(ctx, getUserSMTPKey, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SmtpKey{}
	for rows.Next() {
		var i SmtpKey
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.KeyName,
			&i.Password,
			&i.Status,
			&i.SmtpLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSmtpKeys = `-- name: GetUserSmtpKeys :many
SELECT id, company_id, user_id, key_name, password, status, smtp_login, created_at, updated_at, deleted_at FROM smtp_keys WHERE user_id = $1  AND deleted_at IS NULL
`

func (q *Queries) GetUserSmtpKeys(ctx context.Context, userID uuid.UUID) ([]SmtpKey, error) {
	rows, err := q.db.QueryContext(ctx, getUserSmtpKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SmtpKey{}
	for rows.Next() {
		var i SmtpKey
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.KeyName,
			&i.Password,
			&i.Status,
			&i.SmtpLogin,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteSMTPKey = `-- name: SoftDeleteSMTPKey :exec
UPDATE smtp_keys
SET
    updated_at = now(),
    deleted_at = now()
WHERE
    id = $1
`

func (q *Queries) SoftDeleteSMTPKey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteSMTPKey, id)
	return err
}

const updateSMTPKeyLogin = `-- name: UpdateSMTPKeyLogin :exec
UPDATE smtp_keys SET smtp_login = $1 WHERE user_id = $2
`

type UpdateSMTPKeyLoginParams struct {
	SmtpLogin string    `json:"smtp_login"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateSMTPKeyLogin(ctx context.Context, arg UpdateSMTPKeyLoginParams) error {
	_, err := q.db.ExecContext(ctx, updateSMTPKeyLogin, arg.SmtpLogin, arg.UserID)
	return err
}

const updateSMTPKeyStatus = `-- name: UpdateSMTPKeyStatus :exec
UPDATE smtp_keys
SET
    status = $1,
    updated_at = now()
WHERE
    id = $2
    AND user_id = $3
`

type UpdateSMTPKeyStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateSMTPKeyStatus(ctx context.Context, arg UpdateSMTPKeyStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSMTPKeyStatus, arg.Status, arg.ID, arg.UserID)
	return err
}
