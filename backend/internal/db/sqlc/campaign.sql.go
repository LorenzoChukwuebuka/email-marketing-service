// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: campaign.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const archiveCampaign = `-- name: ArchiveCampaign :one
UPDATE campaigns
SET 
    is_archived = true,
    updated_at = CURRENT_TIMESTAMP
WHERE 
    id = $1
    AND deleted_at IS NULL
RETURNING id, company_id, name, subject, preview_text, user_id, sender_from_name, template_id, sent_template_id, recipient_info, is_published, status, track_type, is_archived, sent_at, sender, scheduled_at, has_custom_logo, created_at, updated_at, deleted_at
`

func (q *Queries) ArchiveCampaign(ctx context.Context, id uuid.UUID) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, archiveCampaign, id)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Subject,
		&i.PreviewText,
		&i.UserID,
		&i.SenderFromName,
		&i.TemplateID,
		&i.SentTemplateID,
		&i.RecipientInfo,
		&i.IsPublished,
		&i.Status,
		&i.TrackType,
		&i.IsArchived,
		&i.SentAt,
		&i.Sender,
		&i.ScheduledAt,
		&i.HasCustomLogo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const checkCampaignNameExists = `-- name: CheckCampaignNameExists :one
SELECT 
    EXISTS (
        SELECT 1 
        FROM campaigns 
        WHERE name = $1 
        AND company_id = $2
        AND deleted_at IS NULL
    ) AS campaign_exists
`

type CheckCampaignNameExistsParams struct {
	Name      string    `json:"name"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) CheckCampaignNameExists(ctx context.Context, arg CheckCampaignNameExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkCampaignNameExists, arg.Name, arg.CompanyID)
	var campaign_exists bool
	err := row.Scan(&campaign_exists)
	return campaign_exists, err
}

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO campaigns (
    company_id,
    name,
    subject,
    preview_text,
    user_id,
    sender_from_name,
    template_id,
    recipient_info,
    status,
    track_type,
    sender,
    scheduled_at,
    has_custom_logo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, company_id, name, subject, preview_text, user_id, sender_from_name, template_id, sent_template_id, recipient_info, is_published, status, track_type, is_archived, sent_at, sender, scheduled_at, has_custom_logo, created_at, updated_at, deleted_at
`

type CreateCampaignParams struct {
	CompanyID      uuid.UUID      `json:"company_id"`
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	UserID         uuid.UUID      `json:"user_id"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, createCampaign,
		arg.CompanyID,
		arg.Name,
		arg.Subject,
		arg.PreviewText,
		arg.UserID,
		arg.SenderFromName,
		arg.TemplateID,
		arg.RecipientInfo,
		arg.Status,
		arg.TrackType,
		arg.Sender,
		arg.ScheduledAt,
		arg.HasCustomLogo,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Subject,
		&i.PreviewText,
		&i.UserID,
		&i.SenderFromName,
		&i.TemplateID,
		&i.SentTemplateID,
		&i.RecipientInfo,
		&i.IsPublished,
		&i.Status,
		&i.TrackType,
		&i.IsArchived,
		&i.SentAt,
		&i.Sender,
		&i.ScheduledAt,
		&i.HasCustomLogo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCampaignByID = `-- name: GetCampaignByID :one
SELECT 
    c.id, c.company_id, c.name, c.subject, c.preview_text, c.user_id, c.sender_from_name, c.template_id, c.sent_template_id, c.recipient_info, c.is_published, c.status, c.track_type, c.is_archived, c.sent_at, c.sender, c.scheduled_at, c.has_custom_logo, c.created_at, c.updated_at, c.deleted_at,
    u.fullname AS user_fullname,
    u.email AS user_email,
    u.picture AS user_picture
FROM 
    campaigns c
LEFT JOIN 
    users u ON c.user_id = u.id
WHERE 
    c.id = $1
    AND c.deleted_at IS NULL
`

type GetCampaignByIDRow struct {
	ID             uuid.UUID      `json:"id"`
	CompanyID      uuid.UUID      `json:"company_id"`
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	UserID         uuid.UUID      `json:"user_id"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	SentTemplateID uuid.NullUUID  `json:"sent_template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	IsPublished    sql.NullBool   `json:"is_published"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	IsArchived     sql.NullBool   `json:"is_archived"`
	SentAt         sql.NullTime   `json:"sent_at"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	UserFullname   sql.NullString `json:"user_fullname"`
	UserEmail      sql.NullString `json:"user_email"`
	UserPicture    sql.NullString `json:"user_picture"`
}

func (q *Queries) GetCampaignByID(ctx context.Context, id uuid.UUID) (GetCampaignByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCampaignByID, id)
	var i GetCampaignByIDRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Subject,
		&i.PreviewText,
		&i.UserID,
		&i.SenderFromName,
		&i.TemplateID,
		&i.SentTemplateID,
		&i.RecipientInfo,
		&i.IsPublished,
		&i.Status,
		&i.TrackType,
		&i.IsArchived,
		&i.SentAt,
		&i.Sender,
		&i.ScheduledAt,
		&i.HasCustomLogo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserFullname,
		&i.UserEmail,
		&i.UserPicture,
	)
	return i, err
}

const getCampaignsByTemplateType = `-- name: GetCampaignsByTemplateType :many
SELECT 
    c.id, c.company_id, c.name, c.subject, c.preview_text, c.user_id, c.sender_from_name, c.template_id, c.sent_template_id, c.recipient_info, c.is_published, c.status, c.track_type, c.is_archived, c.sent_at, c.sender, c.scheduled_at, c.has_custom_logo, c.created_at, c.updated_at, c.deleted_at,
    t.type AS template_type,
    u.fullname AS user_fullname,
    comp.companyname AS company_name
FROM 
    campaigns c
JOIN 
    templates t ON c.template_id = t.id
LEFT JOIN 
    users u ON c.user_id = u.id
LEFT JOIN 
    companies comp ON c.company_id = comp.id
WHERE 
    t.type = $1
    AND c.deleted_at IS NULL
ORDER BY 
    c.created_at DESC
LIMIT $2
OFFSET $3
`

type GetCampaignsByTemplateTypeParams struct {
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetCampaignsByTemplateTypeRow struct {
	ID             uuid.UUID      `json:"id"`
	CompanyID      uuid.UUID      `json:"company_id"`
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	UserID         uuid.UUID      `json:"user_id"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	SentTemplateID uuid.NullUUID  `json:"sent_template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	IsPublished    sql.NullBool   `json:"is_published"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	IsArchived     sql.NullBool   `json:"is_archived"`
	SentAt         sql.NullTime   `json:"sent_at"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	TemplateType   string         `json:"template_type"`
	UserFullname   sql.NullString `json:"user_fullname"`
	CompanyName    sql.NullString `json:"company_name"`
}

func (q *Queries) GetCampaignsByTemplateType(ctx context.Context, arg GetCampaignsByTemplateTypeParams) ([]GetCampaignsByTemplateTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getCampaignsByTemplateType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCampaignsByTemplateTypeRow{}
	for rows.Next() {
		var i GetCampaignsByTemplateTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Subject,
			&i.PreviewText,
			&i.UserID,
			&i.SenderFromName,
			&i.TemplateID,
			&i.SentTemplateID,
			&i.RecipientInfo,
			&i.IsPublished,
			&i.Status,
			&i.TrackType,
			&i.IsArchived,
			&i.SentAt,
			&i.Sender,
			&i.ScheduledAt,
			&i.HasCustomLogo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TemplateType,
			&i.UserFullname,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteCampaign = `-- name: HardDeleteCampaign :exec
DELETE FROM campaigns
WHERE id = $1
`

func (q *Queries) HardDeleteCampaign(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, hardDeleteCampaign, id)
	return err
}

const listCampaigns = `-- name: ListCampaigns :many
SELECT 
    c.id, c.company_id, c.name, c.subject, c.preview_text, c.user_id, c.sender_from_name, c.template_id, c.sent_template_id, c.recipient_info, c.is_published, c.status, c.track_type, c.is_archived, c.sent_at, c.sender, c.scheduled_at, c.has_custom_logo, c.created_at, c.updated_at, c.deleted_at,
    u.fullname AS user_fullname,
    u.email AS user_email,
    comp.companyname AS company_name
FROM 
    campaigns c
LEFT JOIN 
    users u ON c.user_id = u.id
LEFT JOIN 
    companies comp ON c.company_id = comp.id
WHERE 
    c.deleted_at IS NULL
ORDER BY 
    c.created_at DESC
LIMIT $1
OFFSET $2
`

type ListCampaignsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCampaignsRow struct {
	ID             uuid.UUID      `json:"id"`
	CompanyID      uuid.UUID      `json:"company_id"`
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	UserID         uuid.UUID      `json:"user_id"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	SentTemplateID uuid.NullUUID  `json:"sent_template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	IsPublished    sql.NullBool   `json:"is_published"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	IsArchived     sql.NullBool   `json:"is_archived"`
	SentAt         sql.NullTime   `json:"sent_at"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	UserFullname   sql.NullString `json:"user_fullname"`
	UserEmail      sql.NullString `json:"user_email"`
	CompanyName    sql.NullString `json:"company_name"`
}

func (q *Queries) ListCampaigns(ctx context.Context, arg ListCampaignsParams) ([]ListCampaignsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaigns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignsRow{}
	for rows.Next() {
		var i ListCampaignsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Subject,
			&i.PreviewText,
			&i.UserID,
			&i.SenderFromName,
			&i.TemplateID,
			&i.SentTemplateID,
			&i.RecipientInfo,
			&i.IsPublished,
			&i.Status,
			&i.TrackType,
			&i.IsArchived,
			&i.SentAt,
			&i.Sender,
			&i.ScheduledAt,
			&i.HasCustomLogo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserFullname,
			&i.UserEmail,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignsByCompanyID = `-- name: ListCampaignsByCompanyID :many
SELECT 
    c.id, c.company_id, c.name, c.subject, c.preview_text, c.user_id, c.sender_from_name, c.template_id, c.sent_template_id, c.recipient_info, c.is_published, c.status, c.track_type, c.is_archived, c.sent_at, c.sender, c.scheduled_at, c.has_custom_logo, c.created_at, c.updated_at, c.deleted_at,
    u.fullname AS user_fullname,
    u.email AS user_email,
    comp.companyname AS company_name
FROM 
    campaigns c
LEFT JOIN 
    users u ON c.user_id = u.id
LEFT JOIN 
    companies comp ON c.company_id = comp.id
WHERE 
    c.company_id = $1
    AND c.deleted_at IS NULL
ORDER BY 
    c.created_at DESC
LIMIT $2
OFFSET $3
`

type ListCampaignsByCompanyIDParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListCampaignsByCompanyIDRow struct {
	ID             uuid.UUID      `json:"id"`
	CompanyID      uuid.UUID      `json:"company_id"`
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	UserID         uuid.UUID      `json:"user_id"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	SentTemplateID uuid.NullUUID  `json:"sent_template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	IsPublished    sql.NullBool   `json:"is_published"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	IsArchived     sql.NullBool   `json:"is_archived"`
	SentAt         sql.NullTime   `json:"sent_at"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	UserFullname   sql.NullString `json:"user_fullname"`
	UserEmail      sql.NullString `json:"user_email"`
	CompanyName    sql.NullString `json:"company_name"`
}

func (q *Queries) ListCampaignsByCompanyID(ctx context.Context, arg ListCampaignsByCompanyIDParams) ([]ListCampaignsByCompanyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignsByCompanyID, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignsByCompanyIDRow{}
	for rows.Next() {
		var i ListCampaignsByCompanyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Subject,
			&i.PreviewText,
			&i.UserID,
			&i.SenderFromName,
			&i.TemplateID,
			&i.SentTemplateID,
			&i.RecipientInfo,
			&i.IsPublished,
			&i.Status,
			&i.TrackType,
			&i.IsArchived,
			&i.SentAt,
			&i.Sender,
			&i.ScheduledAt,
			&i.HasCustomLogo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserFullname,
			&i.UserEmail,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignsByUserID = `-- name: ListCampaignsByUserID :many
SELECT 
    c.id, c.company_id, c.name, c.subject, c.preview_text, c.user_id, c.sender_from_name, c.template_id, c.sent_template_id, c.recipient_info, c.is_published, c.status, c.track_type, c.is_archived, c.sent_at, c.sender, c.scheduled_at, c.has_custom_logo, c.created_at, c.updated_at, c.deleted_at,
    u.fullname AS user_fullname,
    u.email AS user_email,
    comp.companyname AS company_name
FROM 
    campaigns c
LEFT JOIN 
    users u ON c.user_id = u.id
LEFT JOIN 
    companies comp ON c.company_id = comp.id
WHERE 
    c.user_id = $1
    AND c.deleted_at IS NULL
ORDER BY 
    c.created_at DESC
LIMIT $2
OFFSET $3
`

type ListCampaignsByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListCampaignsByUserIDRow struct {
	ID             uuid.UUID      `json:"id"`
	CompanyID      uuid.UUID      `json:"company_id"`
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	UserID         uuid.UUID      `json:"user_id"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	SentTemplateID uuid.NullUUID  `json:"sent_template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	IsPublished    sql.NullBool   `json:"is_published"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	IsArchived     sql.NullBool   `json:"is_archived"`
	SentAt         sql.NullTime   `json:"sent_at"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	UserFullname   sql.NullString `json:"user_fullname"`
	UserEmail      sql.NullString `json:"user_email"`
	CompanyName    sql.NullString `json:"company_name"`
}

func (q *Queries) ListCampaignsByUserID(ctx context.Context, arg ListCampaignsByUserIDParams) ([]ListCampaignsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignsByUserIDRow{}
	for rows.Next() {
		var i ListCampaignsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Subject,
			&i.PreviewText,
			&i.UserID,
			&i.SenderFromName,
			&i.TemplateID,
			&i.SentTemplateID,
			&i.RecipientInfo,
			&i.IsPublished,
			&i.Status,
			&i.TrackType,
			&i.IsArchived,
			&i.SentAt,
			&i.Sender,
			&i.ScheduledAt,
			&i.HasCustomLogo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserFullname,
			&i.UserEmail,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCampaignAsSent = `-- name: MarkCampaignAsSent :one
UPDATE campaigns
SET 
    status = 'sent',
    sent_at = CURRENT_TIMESTAMP,
    sent_template_id = template_id,
    updated_at = CURRENT_TIMESTAMP
WHERE 
    id = $1
    AND deleted_at IS NULL
RETURNING id, company_id, name, subject, preview_text, user_id, sender_from_name, template_id, sent_template_id, recipient_info, is_published, status, track_type, is_archived, sent_at, sender, scheduled_at, has_custom_logo, created_at, updated_at, deleted_at
`

func (q *Queries) MarkCampaignAsSent(ctx context.Context, id uuid.UUID) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, markCampaignAsSent, id)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Subject,
		&i.PreviewText,
		&i.UserID,
		&i.SenderFromName,
		&i.TemplateID,
		&i.SentTemplateID,
		&i.RecipientInfo,
		&i.IsPublished,
		&i.Status,
		&i.TrackType,
		&i.IsArchived,
		&i.SentAt,
		&i.Sender,
		&i.ScheduledAt,
		&i.HasCustomLogo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteCampaign = `-- name: SoftDeleteCampaign :exec
UPDATE campaigns
SET 
    deleted_at = CURRENT_TIMESTAMP
WHERE 
    id = $1
    AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteCampaign(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteCampaign, id)
	return err
}

const updateCampaign = `-- name: UpdateCampaign :one
UPDATE campaigns
SET 
    name = COALESCE($1, name),
    subject = COALESCE($2, subject),
    preview_text = COALESCE($3, preview_text),
    sender_from_name = COALESCE($4, sender_from_name),
    template_id = COALESCE($5, template_id),
    recipient_info = COALESCE($6, recipient_info),
    status = COALESCE($7, status),
    track_type = COALESCE($8, track_type),
    sender = COALESCE($9, sender),
    scheduled_at = COALESCE($10, scheduled_at),
    has_custom_logo = COALESCE($11, has_custom_logo),
    is_published = COALESCE($12, is_published),
    is_archived = COALESCE($13, is_archived),
    updated_at = CURRENT_TIMESTAMP
WHERE 
    id = $14
    AND deleted_at IS NULL
RETURNING id, company_id, name, subject, preview_text, user_id, sender_from_name, template_id, sent_template_id, recipient_info, is_published, status, track_type, is_archived, sent_at, sender, scheduled_at, has_custom_logo, created_at, updated_at, deleted_at
`

type UpdateCampaignParams struct {
	Name           string         `json:"name"`
	Subject        sql.NullString `json:"subject"`
	PreviewText    sql.NullString `json:"preview_text"`
	SenderFromName sql.NullString `json:"sender_from_name"`
	TemplateID     uuid.NullUUID  `json:"template_id"`
	RecipientInfo  sql.NullString `json:"recipient_info"`
	Status         sql.NullString `json:"status"`
	TrackType      sql.NullString `json:"track_type"`
	Sender         sql.NullString `json:"sender"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	HasCustomLogo  sql.NullBool   `json:"has_custom_logo"`
	IsPublished    sql.NullBool   `json:"is_published"`
	IsArchived     sql.NullBool   `json:"is_archived"`
	ID             uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, updateCampaign,
		arg.Name,
		arg.Subject,
		arg.PreviewText,
		arg.SenderFromName,
		arg.TemplateID,
		arg.RecipientInfo,
		arg.Status,
		arg.TrackType,
		arg.Sender,
		arg.ScheduledAt,
		arg.HasCustomLogo,
		arg.IsPublished,
		arg.IsArchived,
		arg.ID,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Subject,
		&i.PreviewText,
		&i.UserID,
		&i.SenderFromName,
		&i.TemplateID,
		&i.SentTemplateID,
		&i.RecipientInfo,
		&i.IsPublished,
		&i.Status,
		&i.TrackType,
		&i.IsArchived,
		&i.SentAt,
		&i.Sender,
		&i.ScheduledAt,
		&i.HasCustomLogo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
