// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invitations.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const cancelInvitation = `-- name: CancelInvitation :exec
UPDATE invitations 
SET 
    status = 'cancelled',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) CancelInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, cancelInvitation, id)
	return err
}

const cleanupExpiredInvitations = `-- name: CleanupExpiredInvitations :exec
UPDATE invitations 
SET 
    status = 'expired',
    updated_at = now()
WHERE status = 'pending' AND expires_at < now() AND deleted_at IS NULL
`

func (q *Queries) CleanupExpiredInvitations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredInvitations)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (
    company_id,
    invited_by,
    email,
    token,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, company_id, invited_by, email, token, status, expires_at, accepted_at, accepted_by, created_at, updated_at, deleted_at
`

type CreateInvitationParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	InvitedBy uuid.UUID `json:"invited_by"`
	Email     string    `json:"email"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, createInvitation,
		arg.CompanyID,
		arg.InvitedBy,
		arg.Email,
		arg.Token,
		arg.ExpiresAt,
	)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.InvitedBy,
		&i.Email,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
UPDATE invitations 
SET 
    deleted_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteInvitation, id)
	return err
}

const expireInvitation = `-- name: ExpireInvitation :exec
UPDATE invitations 
SET 
    status = 'expired',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) ExpireInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, expireInvitation, id)
	return err
}

const getInvitationByAcceptedUser = `-- name: GetInvitationByAcceptedUser :one
SELECT 
    i.id, i.company_id, i.invited_by, i.email, i.token, i.status, i.expires_at, i.accepted_at, i.accepted_by, i.created_at, i.updated_at, i.deleted_at,
    invited_by_user.fullname as invited_by_name,
    c.companyname
FROM invitations i
JOIN users invited_by_user ON i.invited_by = invited_by_user.id
JOIN companies c ON i.company_id = c.id
WHERE i.accepted_by = $1 AND i.status = 'accepted' AND i.deleted_at IS NULL
`

type GetInvitationByAcceptedUserRow struct {
	ID            uuid.UUID      `json:"id"`
	CompanyID     uuid.UUID      `json:"company_id"`
	InvitedBy     uuid.UUID      `json:"invited_by"`
	Email         string         `json:"email"`
	Token         string         `json:"token"`
	Status        string         `json:"status"`
	ExpiresAt     time.Time      `json:"expires_at"`
	AcceptedAt    sql.NullTime   `json:"accepted_at"`
	AcceptedBy    uuid.NullUUID  `json:"accepted_by"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	DeletedAt     sql.NullTime   `json:"deleted_at"`
	InvitedByName string         `json:"invited_by_name"`
	Companyname   sql.NullString `json:"companyname"`
}

func (q *Queries) GetInvitationByAcceptedUser(ctx context.Context, acceptedBy uuid.NullUUID) (GetInvitationByAcceptedUserRow, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByAcceptedUser, acceptedBy)
	var i GetInvitationByAcceptedUserRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.InvitedBy,
		&i.Email,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvitedByName,
		&i.Companyname,
	)
	return i, err
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, company_id, invited_by, email, token, status, expires_at, accepted_at, accepted_by, created_at, updated_at, deleted_at FROM invitations 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInvitationByID(ctx context.Context, id uuid.UUID) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByID, id)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.InvitedBy,
		&i.Email,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT 
    i.id, i.company_id, i.invited_by, i.email, i.token, i.status, i.expires_at, i.accepted_at, i.accepted_by, i.created_at, i.updated_at, i.deleted_at,
    c.companyname,
    u.fullname as invited_by_name
FROM invitations i
JOIN companies c ON i.company_id = c.id
JOIN users u ON i.invited_by = u.id
WHERE i.token = $1 AND i.deleted_at IS NULL
`

type GetInvitationByTokenRow struct {
	ID            uuid.UUID      `json:"id"`
	CompanyID     uuid.UUID      `json:"company_id"`
	InvitedBy     uuid.UUID      `json:"invited_by"`
	Email         string         `json:"email"`
	Token         string         `json:"token"`
	Status        string         `json:"status"`
	ExpiresAt     time.Time      `json:"expires_at"`
	AcceptedAt    sql.NullTime   `json:"accepted_at"`
	AcceptedBy    uuid.NullUUID  `json:"accepted_by"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	DeletedAt     sql.NullTime   `json:"deleted_at"`
	Companyname   sql.NullString `json:"companyname"`
	InvitedByName string         `json:"invited_by_name"`
}

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.InvitedBy,
		&i.Email,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Companyname,
		&i.InvitedByName,
	)
	return i, err
}

const getInvitationStats = `-- name: GetInvitationStats :one
SELECT 
    COUNT(*) as total_invitations,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_invitations,
    COUNT(CASE WHEN status = 'accepted' THEN 1 END) as accepted_invitations,
    COUNT(CASE WHEN status = 'expired' THEN 1 END) as expired_invitations,
    COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_invitations
FROM invitations 
WHERE company_id = $1 AND deleted_at IS NULL
`

type GetInvitationStatsRow struct {
	TotalInvitations     int64 `json:"total_invitations"`
	PendingInvitations   int64 `json:"pending_invitations"`
	AcceptedInvitations  int64 `json:"accepted_invitations"`
	ExpiredInvitations   int64 `json:"expired_invitations"`
	CancelledInvitations int64 `json:"cancelled_invitations"`
}

func (q *Queries) GetInvitationStats(ctx context.Context, companyID uuid.UUID) (GetInvitationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getInvitationStats, companyID)
	var i GetInvitationStatsRow
	err := row.Scan(
		&i.TotalInvitations,
		&i.PendingInvitations,
		&i.AcceptedInvitations,
		&i.ExpiredInvitations,
		&i.CancelledInvitations,
	)
	return i, err
}

const getInvitationsByCompany = `-- name: GetInvitationsByCompany :many
SELECT 
    i.id, i.company_id, i.invited_by, i.email, i.token, i.status, i.expires_at, i.accepted_at, i.accepted_by, i.created_at, i.updated_at, i.deleted_at,
    u.fullname as invited_by_name
FROM invitations i
JOIN users u ON i.invited_by = u.id
WHERE i.company_id = $1 AND i.deleted_at IS NULL
ORDER BY i.created_at DESC
`

type GetInvitationsByCompanyRow struct {
	ID            uuid.UUID     `json:"id"`
	CompanyID     uuid.UUID     `json:"company_id"`
	InvitedBy     uuid.UUID     `json:"invited_by"`
	Email         string        `json:"email"`
	Token         string        `json:"token"`
	Status        string        `json:"status"`
	ExpiresAt     time.Time     `json:"expires_at"`
	AcceptedAt    sql.NullTime  `json:"accepted_at"`
	AcceptedBy    uuid.NullUUID `json:"accepted_by"`
	CreatedAt     time.Time     `json:"created_at"`
	UpdatedAt     time.Time     `json:"updated_at"`
	DeletedAt     sql.NullTime  `json:"deleted_at"`
	InvitedByName string        `json:"invited_by_name"`
}

func (q *Queries) GetInvitationsByCompany(ctx context.Context, companyID uuid.UUID) ([]GetInvitationsByCompanyRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByCompanyRow{}
	for rows.Next() {
		var i GetInvitationsByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.InvitedBy,
			&i.Email,
			&i.Token,
			&i.Status,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvitedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvitationsByEmail = `-- name: GetPendingInvitationsByEmail :many
SELECT 
    i.id, i.company_id, i.invited_by, i.email, i.token, i.status, i.expires_at, i.accepted_at, i.accepted_by, i.created_at, i.updated_at, i.deleted_at,
    c.companyname,
    u.fullname as invited_by_name
FROM invitations i
JOIN companies c ON i.company_id = c.id
JOIN users u ON i.invited_by = u.id
WHERE i.email = $1 AND i.status = 'pending' AND i.expires_at > now() AND i.deleted_at IS NULL
`

type GetPendingInvitationsByEmailRow struct {
	ID            uuid.UUID      `json:"id"`
	CompanyID     uuid.UUID      `json:"company_id"`
	InvitedBy     uuid.UUID      `json:"invited_by"`
	Email         string         `json:"email"`
	Token         string         `json:"token"`
	Status        string         `json:"status"`
	ExpiresAt     time.Time      `json:"expires_at"`
	AcceptedAt    sql.NullTime   `json:"accepted_at"`
	AcceptedBy    uuid.NullUUID  `json:"accepted_by"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	DeletedAt     sql.NullTime   `json:"deleted_at"`
	Companyname   sql.NullString `json:"companyname"`
	InvitedByName string         `json:"invited_by_name"`
}

func (q *Queries) GetPendingInvitationsByEmail(ctx context.Context, email string) ([]GetPendingInvitationsByEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingInvitationsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsByEmailRow{}
	for rows.Next() {
		var i GetPendingInvitationsByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.InvitedBy,
			&i.Email,
			&i.Token,
			&i.Status,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Companyname,
			&i.InvitedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWhoAcceptedInvitation = `-- name: GetUserWhoAcceptedInvitation :one
SELECT 
    u.id, u.fullname, u.company_id, u.email, u.phonenumber, u.password, u.google_id, u.picture, u.verified, u.blocked, u.verified_at, u.status, u.scheduled_for_deletion, u.scheduled_deletion_at, u.last_login_at, u.created_at, u.updated_at, u.deleted_at,
    i.accepted_at,
    i.created_at as invitation_created_at
FROM invitations i
JOIN users u ON i.accepted_by = u.id
WHERE i.id = $1 AND i.status = 'accepted' AND i.deleted_at IS NULL
`

type GetUserWhoAcceptedInvitationRow struct {
	ID                   uuid.UUID      `json:"id"`
	Fullname             string         `json:"fullname"`
	CompanyID            uuid.UUID      `json:"company_id"`
	Email                string         `json:"email"`
	Phonenumber          sql.NullString `json:"phonenumber"`
	Password             sql.NullString `json:"password"`
	GoogleID             sql.NullString `json:"google_id"`
	Picture              sql.NullString `json:"picture"`
	Verified             bool           `json:"verified"`
	Blocked              bool           `json:"blocked"`
	VerifiedAt           sql.NullTime   `json:"verified_at"`
	Status               string         `json:"status"`
	ScheduledForDeletion bool           `json:"scheduled_for_deletion"`
	ScheduledDeletionAt  sql.NullTime   `json:"scheduled_deletion_at"`
	LastLoginAt          sql.NullTime   `json:"last_login_at"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	DeletedAt            sql.NullTime   `json:"deleted_at"`
	AcceptedAt           sql.NullTime   `json:"accepted_at"`
	InvitationCreatedAt  time.Time      `json:"invitation_created_at"`
}

func (q *Queries) GetUserWhoAcceptedInvitation(ctx context.Context, id uuid.UUID) (GetUserWhoAcceptedInvitationRow, error) {
	row := q.db.QueryRowContext(ctx, getUserWhoAcceptedInvitation, id)
	var i GetUserWhoAcceptedInvitationRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.CompanyID,
		&i.Email,
		&i.Phonenumber,
		&i.Password,
		&i.GoogleID,
		&i.Picture,
		&i.Verified,
		&i.Blocked,
		&i.VerifiedAt,
		&i.Status,
		&i.ScheduledForDeletion,
		&i.ScheduledDeletionAt,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.InvitationCreatedAt,
	)
	return i, err
}

const getUsersFromInvitations = `-- name: GetUsersFromInvitations :many
SELECT 
    u.id, u.fullname, u.company_id, u.email, u.phonenumber, u.password, u.google_id, u.picture, u.verified, u.blocked, u.verified_at, u.status, u.scheduled_for_deletion, u.scheduled_deletion_at, u.last_login_at, u.created_at, u.updated_at, u.deleted_at,
    i.created_at as invitation_created_at,
    i.accepted_at,
    invited_by_user.fullname as invited_by_name
FROM invitations i
JOIN users u ON i.accepted_by = u.id
JOIN users invited_by_user ON i.invited_by = invited_by_user.id
WHERE i.company_id = $1 AND i.status = 'accepted' AND i.deleted_at IS NULL
ORDER BY i.accepted_at DESC
`

type GetUsersFromInvitationsRow struct {
	ID                   uuid.UUID      `json:"id"`
	Fullname             string         `json:"fullname"`
	CompanyID            uuid.UUID      `json:"company_id"`
	Email                string         `json:"email"`
	Phonenumber          sql.NullString `json:"phonenumber"`
	Password             sql.NullString `json:"password"`
	GoogleID             sql.NullString `json:"google_id"`
	Picture              sql.NullString `json:"picture"`
	Verified             bool           `json:"verified"`
	Blocked              bool           `json:"blocked"`
	VerifiedAt           sql.NullTime   `json:"verified_at"`
	Status               string         `json:"status"`
	ScheduledForDeletion bool           `json:"scheduled_for_deletion"`
	ScheduledDeletionAt  sql.NullTime   `json:"scheduled_deletion_at"`
	LastLoginAt          sql.NullTime   `json:"last_login_at"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	DeletedAt            sql.NullTime   `json:"deleted_at"`
	InvitationCreatedAt  time.Time      `json:"invitation_created_at"`
	AcceptedAt           sql.NullTime   `json:"accepted_at"`
	InvitedByName        string         `json:"invited_by_name"`
}

func (q *Queries) GetUsersFromInvitations(ctx context.Context, companyID uuid.UUID) ([]GetUsersFromInvitationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersFromInvitations, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersFromInvitationsRow{}
	for rows.Next() {
		var i GetUsersFromInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Fullname,
			&i.CompanyID,
			&i.Email,
			&i.Phonenumber,
			&i.Password,
			&i.GoogleID,
			&i.Picture,
			&i.Verified,
			&i.Blocked,
			&i.VerifiedAt,
			&i.Status,
			&i.ScheduledForDeletion,
			&i.ScheduledDeletionAt,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvitationCreatedAt,
			&i.AcceptedAt,
			&i.InvitedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :one
UPDATE invitations 
SET 
    status = $2,
    accepted_at = CASE WHEN $2 = 'accepted' THEN now() ELSE accepted_at END,
    accepted_by = $3,
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, company_id, invited_by, email, token, status, expires_at, accepted_at, accepted_by, created_at, updated_at, deleted_at
`

type UpdateInvitationStatusParams struct {
	ID         uuid.UUID     `json:"id"`
	Status     string        `json:"status"`
	AcceptedBy uuid.NullUUID `json:"accepted_by"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, updateInvitationStatus, arg.ID, arg.Status, arg.AcceptedBy)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.InvitedBy,
		&i.Email,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
