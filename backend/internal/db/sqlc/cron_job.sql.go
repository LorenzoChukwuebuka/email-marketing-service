// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cron_job.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createJobExecutionLog = `-- name: CreateJobExecutionLog :one
INSERT INTO job_execution_logs (
    job_schedule_id,
    job_name,
    started_at,
    status
) VALUES (
    $1, $2, $3, $4
) RETURNING id
`

type CreateJobExecutionLogParams struct {
	JobScheduleID uuid.NullUUID `json:"job_schedule_id"`
	JobName       string        `json:"job_name"`
	StartedAt     time.Time     `json:"started_at"`
	Status        string        `json:"status"`
}

func (q *Queries) CreateJobExecutionLog(ctx context.Context, arg CreateJobExecutionLogParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createJobExecutionLog,
		arg.JobScheduleID,
		arg.JobName,
		arg.StartedAt,
		arg.Status,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createJobSchedule = `-- name: CreateJobSchedule :one
INSERT INTO job_schedules (
    job_name,
    job_type,
    cron_schedule,
    enabled,
    description,
    timeout_seconds,
    max_retries,
    failure_count,
    total_runs,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, 0, 0, NOW(), NOW()
) RETURNING id
`

type CreateJobScheduleParams struct {
	JobName        string         `json:"job_name"`
	JobType        string         `json:"job_type"`
	CronSchedule   string         `json:"cron_schedule"`
	Enabled        sql.NullBool   `json:"enabled"`
	Description    sql.NullString `json:"description"`
	TimeoutSeconds sql.NullInt32  `json:"timeout_seconds"`
	MaxRetries     sql.NullInt32  `json:"max_retries"`
}

func (q *Queries) CreateJobSchedule(ctx context.Context, arg CreateJobScheduleParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createJobSchedule,
		arg.JobName,
		arg.JobType,
		arg.CronSchedule,
		arg.Enabled,
		arg.Description,
		arg.TimeoutSeconds,
		arg.MaxRetries,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const disableJob = `-- name: DisableJob :exec
UPDATE job_schedules 
SET 
    enabled = false,
    updated_at = NOW()
WHERE job_name = $1
`

func (q *Queries) DisableJob(ctx context.Context, jobName string) error {
	_, err := q.db.ExecContext(ctx, disableJob, jobName)
	return err
}

const enableJob = `-- name: EnableJob :exec
UPDATE job_schedules 
SET 
    enabled = true,
    updated_at = NOW()
WHERE job_name = $1
`

func (q *Queries) EnableJob(ctx context.Context, jobName string) error {
	_, err := q.db.ExecContext(ctx, enableJob, jobName)
	return err
}

const getEnabledJobSchedules = `-- name: GetEnabledJobSchedules :many
SELECT 
    id,
    job_name,
    job_type,
    cron_schedule,
    enabled,
    description,
    timeout_seconds,
    max_retries,
    last_run_at,
    last_success_at,
    last_failure_at,
    failure_count,
    total_runs,
    created_at,
    updated_at
FROM job_schedules 
WHERE enabled = true
ORDER BY job_name
`

func (q *Queries) GetEnabledJobSchedules(ctx context.Context) ([]JobSchedule, error) {
	rows, err := q.db.QueryContext(ctx, getEnabledJobSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobSchedule{}
	for rows.Next() {
		var i JobSchedule
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.JobType,
			&i.CronSchedule,
			&i.Enabled,
			&i.Description,
			&i.TimeoutSeconds,
			&i.MaxRetries,
			&i.LastRunAt,
			&i.LastSuccessAt,
			&i.LastFailureAt,
			&i.FailureCount,
			&i.TotalRuns,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobExecutionHistory = `-- name: GetJobExecutionHistory :many
SELECT 
    id,
    job_name,
    started_at,
    finished_at,
    status,
    duration_ms,
    error_message,
    output_data,
    created_at
FROM job_execution_logs 
WHERE job_name = $1 
ORDER BY started_at DESC 
LIMIT $2
`

type GetJobExecutionHistoryParams struct {
	JobName string `json:"job_name"`
	Limit   int32  `json:"limit"`
}

type GetJobExecutionHistoryRow struct {
	ID           uuid.UUID             `json:"id"`
	JobName      string                `json:"job_name"`
	StartedAt    time.Time             `json:"started_at"`
	FinishedAt   sql.NullTime          `json:"finished_at"`
	Status       string                `json:"status"`
	DurationMs   sql.NullInt32         `json:"duration_ms"`
	ErrorMessage sql.NullString        `json:"error_message"`
	OutputData   pqtype.NullRawMessage `json:"output_data"`
	CreatedAt    sql.NullTime          `json:"created_at"`
}

func (q *Queries) GetJobExecutionHistory(ctx context.Context, arg GetJobExecutionHistoryParams) ([]GetJobExecutionHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobExecutionHistory, arg.JobName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJobExecutionHistoryRow{}
	for rows.Next() {
		var i GetJobExecutionHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.DurationMs,
			&i.ErrorMessage,
			&i.OutputData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobScheduleByName = `-- name: GetJobScheduleByName :one
SELECT 
    id,
    job_name,
    job_type,
    cron_schedule,
    enabled,
    description,
    timeout_seconds,
    max_retries,
    last_run_at,
    last_success_at,
    last_failure_at,
    failure_count,
    total_runs,
    created_at,
    updated_at
FROM job_schedules 
WHERE job_name = $1
`

func (q *Queries) GetJobScheduleByName(ctx context.Context, jobName string) (JobSchedule, error) {
	row := q.db.QueryRowContext(ctx, getJobScheduleByName, jobName)
	var i JobSchedule
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.JobType,
		&i.CronSchedule,
		&i.Enabled,
		&i.Description,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.LastRunAt,
		&i.LastSuccessAt,
		&i.LastFailureAt,
		&i.FailureCount,
		&i.TotalRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJobExecutionLog = `-- name: UpdateJobExecutionLog :exec
UPDATE job_execution_logs 
SET 
    finished_at = $2,
    status = $3,
    duration_ms = $4,
    error_message = $5,
    output_data = $6
WHERE id = $1
`

type UpdateJobExecutionLogParams struct {
	ID           uuid.UUID             `json:"id"`
	FinishedAt   sql.NullTime          `json:"finished_at"`
	Status       string                `json:"status"`
	DurationMs   sql.NullInt32         `json:"duration_ms"`
	ErrorMessage sql.NullString        `json:"error_message"`
	OutputData   pqtype.NullRawMessage `json:"output_data"`
}

func (q *Queries) UpdateJobExecutionLog(ctx context.Context, arg UpdateJobExecutionLogParams) error {
	_, err := q.db.ExecContext(ctx, updateJobExecutionLog,
		arg.ID,
		arg.FinishedAt,
		arg.Status,
		arg.DurationMs,
		arg.ErrorMessage,
		arg.OutputData,
	)
	return err
}

const updateJobFailure = `-- name: UpdateJobFailure :exec
UPDATE job_schedules 
SET 
    last_failure_at = $2,
    failure_count = failure_count + 1,
    updated_at = NOW()
WHERE job_name = $1
`

type UpdateJobFailureParams struct {
	JobName       string       `json:"job_name"`
	LastFailureAt sql.NullTime `json:"last_failure_at"`
}

func (q *Queries) UpdateJobFailure(ctx context.Context, arg UpdateJobFailureParams) error {
	_, err := q.db.ExecContext(ctx, updateJobFailure, arg.JobName, arg.LastFailureAt)
	return err
}

const updateJobLastRun = `-- name: UpdateJobLastRun :exec
UPDATE job_schedules 
SET 
    last_run_at = $2,
    total_runs = total_runs + 1,
    updated_at = NOW()
WHERE job_name = $1
`

type UpdateJobLastRunParams struct {
	JobName   string       `json:"job_name"`
	LastRunAt sql.NullTime `json:"last_run_at"`
}

func (q *Queries) UpdateJobLastRun(ctx context.Context, arg UpdateJobLastRunParams) error {
	_, err := q.db.ExecContext(ctx, updateJobLastRun, arg.JobName, arg.LastRunAt)
	return err
}

const updateJobSchedule = `-- name: UpdateJobSchedule :exec
UPDATE job_schedules 
SET 
    cron_schedule = $2,
    description = COALESCE($3, description),
    timeout_seconds = COALESCE($4, timeout_seconds),
    max_retries = COALESCE($5, max_retries),
    updated_at = NOW()
WHERE job_name = $1
`

type UpdateJobScheduleParams struct {
	JobName        string         `json:"job_name"`
	CronSchedule   string         `json:"cron_schedule"`
	Description    sql.NullString `json:"description"`
	TimeoutSeconds sql.NullInt32  `json:"timeout_seconds"`
	MaxRetries     sql.NullInt32  `json:"max_retries"`
}

func (q *Queries) UpdateJobSchedule(ctx context.Context, arg UpdateJobScheduleParams) error {
	_, err := q.db.ExecContext(ctx, updateJobSchedule,
		arg.JobName,
		arg.CronSchedule,
		arg.Description,
		arg.TimeoutSeconds,
		arg.MaxRetries,
	)
	return err
}

const updateJobSuccess = `-- name: UpdateJobSuccess :exec
UPDATE job_schedules 
SET 
    last_success_at = $2,
    failure_count = 0,
    updated_at = NOW()
WHERE job_name = $1
`

type UpdateJobSuccessParams struct {
	JobName       string       `json:"job_name"`
	LastSuccessAt sql.NullTime `json:"last_success_at"`
}

func (q *Queries) UpdateJobSuccess(ctx context.Context, arg UpdateJobSuccessParams) error {
	_, err := q.db.ExecContext(ctx, updateJobSuccess, arg.JobName, arg.LastSuccessAt)
	return err
}
